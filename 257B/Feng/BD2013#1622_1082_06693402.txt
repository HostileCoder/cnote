
 
 Key Recovery Using Noised Secret Sharing with Discounts  
Over Large Clouds 
 

 Sushil Jajodia 
George Mason University  
Fairfax, VA, USA 
{jajodia@gmu.edu} 
 
Witold Litwin 
Lamsade, Université Paris Dauphine 
Paris, France 
{witold.litwin@dauphine.fr} 
 
 
Abstract—Encryption key loss problem is Achilles’s heel 
of cryptography. Key escrow helps, but favors 
disclosures. Schemes for recoverable encryption keys 
through noised secret sharing alleviate the dilemma. 
Key owner escrows a specifically encrypted backup. The 
recovery needs a large cloud. Cloud cost, money trail… 
should rarefy illegal attempts. We now propose noised 
secret sharing schemes supporting discounts.  The 
recovery request with discount code lowers the recovery 
complexity, easily by orders of magnitude. A smaller 
cloud may suffice for the same recovery timing. 
Alternatively, same cloud may provide faster recovery 
etc.  Our schemes appear useful for users attracted to 
Big Data, but afraid of possibly humongous 
consequences of the key loss or data disclosure.   
Keywords-clouds; big data; privacy; key recovery. 
I. INTRODUCTION  
Key recovery is a classical goal.  Key escrow, i.e., 
entrusting a key copy with some (escrow) agent, was 
proposed as a basic solution. The idea did not catch. 
Key owners seem fearing the key disclosure, as 
source of irresistible temptations for some. More 
complex key escrow schemes, e.g., with recovery 
rights verification or through secondary encryption of 
the copy with the key entrusted to another party, are 
almost no noticeable in practice. See the related work 
section in [3]. Not having key escrow, on the other 
hand, exposes the data to the key loss, especially if 
the owner disappears with. Modern encryption 
schemes, e.g., AES, make data unrecoverable then.  
The fear of key loss particularly concerns many 
users attracted to Big Data idea.  It is the common 
knowledge that safety and efficiency of related 
manipulations require the data outsourcing to some 
cloud. However, one knows well that most users are 
reluctant to outsource data in clear, [1]. Many can’t 
do it simply by law. Many pro may accept therefore 
the idea only if they may  encrypt  the  outsourcing.  
A  homomorphic  code allows  in particular  for  the  
Thomas Schwarz,  
Universidad Católica del Uruguay 
Montevideo, Uruguay 
{tschwarz@ucu.edu.uy} 
 
 
 
 
 
 
 
arithmetic  calculations  over  the encrypted data 
(directly) in the cloud,  [6].   This is  a  strong  need, 
as  many  Big  Data  queries  use value expressions, 
distributed in addition for efficient evaluation using 
Map-Reduce, [5]. Even with all these tools, many or 
most of these users remain deterred up to now. Big 
Data may render indeed key loss consequences 
accordingly huge. It could worth years of work of 
many people. Vice versa, a misuse of an escrowed 
key copy may result in the cloud content disclosure. 
This may lead to consequences of scale equally 
calamitous.  
Schemes for recoverable encryption through 
noised secret sharing, RENS schemes in short, 
appeared as a new solution to the dilemma, [2] and 
[3]. The key owner escrows a specifically encrypted 
backup. The brute-force key recovery, from the 
backup alone, is always feasible although 
intentionally hard. Its complexity, as measured by the 
number of instructions the recovery may need, is 
arbitrarily fixed by the owner, depending on the trust 
in the escrow agent.  As the result, the recovery 
timing on the escrow’s site (node) alone, should 
become impractical, e.g., should last dozens of days 
at least. This timing results from some key-owner 
defined integer M, called backup (encryption) 
hardness, providing O (M) worst-case complexity. 
Nevertheless, the actual maximal recovery time 
desired by the recovery requestor remains practical. 
The recovery uses a sufficiently large N-node cloud, 
providing about linear O (M / N) recovery speed-up. 
Practical timing, e.g., in minutes, is expected to imply 
N in thousands.  The escrow is not expected to 
maintain such a large cloud on premises.  Hiring it 
from some external provider is then is a necessity. 
That one should be usually somehow costly and 
easily noticeable through numerous logs, money 
trail….  One may expect illegal disclosure attempts, 
e.g., by an escrow side insider, to rarefy. They may be 
SocialCom/PASSAT/BigData/EconCom/BioMedCom 2013
 978-0-7695-5137-1/13 $26.00 © 2013 IEEE
 DOI 10.1109/SocialCom.2013.105
 700

 
 expected much less tempting than from a simple key 
copy.     
We now extend known RENS schemes with the 
concept of discount. As the name suggests, a discount 
results from a code that lowers the recovery cost with 
respect to the brute-force one. The reduction is easily 
by orders of magnitude as it will appear. We speak 
then about the discounted recovery. We furthermore 
rather designate the brute-force one from now on as 
the full-cost one. Technically, the code lowers the 
recovery complexity for both the worst and the 
average cases.  
The code is an m-bit string; m = 0,1…. The m = 0 
tacitly means the no-discount request, i.e., the full-
 cost one. Otherwise, we expect m = 8 or m = 16 at 
most, in practice. With respect to the full-cost 
recovery, such codes lower both complexities, 
respectively 256 for m = 8 and 64K times for m = 16. 
The minimal actual discount is for m = 1 and is 50%. 
Accordingly, the discount may greatly reduce 
recovery timing and/or the cloud size and au finale 
the cloud cost for the requestor.  
The code may appear to the key owner in some 
convenient form. The minimal discount requires only 
retaining that the code is even or odd. Otherwise, one 
choice may be a single 16b Unicode digit. Or, it can 
be one or two (extended) 8b ASCII digits.  
Alternatively, one may choose 2 ÷ 4 hex digits, etc.  
One expects such codes easy to retain, e.g., on a 
smartphone, or simply in memory. Especially, it 
should be very easy for the minimal discount. Recall 
that Europeans are routinely trained to keep in mind 
their 4-digit credit card codes. They are strongly 
advised not to store them anywhere, (especially on the 
credit cards themselves).  
The requestor sends the discount code to the 
escrow within the (discounted) recovery request. The 
code amends the processing of the otherwise always 
feasible full-cost recovery. For any given key, only 
specific codes lead to a discounted recovery.  Any 
discount provided triggers nevertheless a recovery 
attempt with the associated cost. An unsuccessful 
attempt also respects the requestor’s timeline. It 
doubles however the average cost of the successful 
one. Finally, every code is granted successful only for 
one key. For any other one, it basically acts as 
(purely) random guess of what should be the actual 
one.  With costly consequences, we just discussed. 
All together tampering with a discount code should be 
infrequent.  
Globally, we show below that for all these reasons 
discounts appear a highly useful capability for an 
RENS scheme. The existing 2-share schemes 
generalize easily. The key remains “never-lost”, with 
(illegal) disclosure cumbersome at will for the 
attacker. Yet, the legal recovery by the discount 
possessor remains cheap and thus practical. This 
combination is unique up to now for a key recovery 
scheme. Especially, it can greatly help the already 
mentioned potential Big Data users.  
Below, we first define and analyze the RENS 
schemes with discounts using, so-called 2-share 
noised secret sharing. We generalize for this purpose 
the two related schemes defined in [2]. These are told 
respectively static and scalable and are analyzed 
further more in depth in [3]. We define the backup 
and the discount creation, then the discount-based 
recovery calculation. Next, we analyze the 
correctness, the complexity and the safety of the 
resulting schemes. Afterwards, we generalize the 2-
 share recovery calculation to a (k + 1) -share one with 
k > 1 at key owner will. We show attractive property 
of such schemes. Next, we briefly address the related 
work and we finally conclude.  Space limitation 
forced us to evacuate all the figures we discuss into 
[6]. 
II. BACKUP CREATION 
Let K be the key to backup, e.g. a 256b long AES 
key. The key owner or rather the owner’s client 
program, running on owner’s site, say O in every 
case, first creates a usual 2-share secret, with shares, 
say s0 and s1 = K XOR s0, Fig. 1a. It is the common 
knowledge that K = s0  XOR s1.  Next, O chooses 
some time D, e.g., 70 days. D is the intended recovery 
time at the escrow’s site alone, assuming it a 1-node 
(core) configuration. The choice of D value reflects 
O’s trust in the escrow service that that no (illegal) 
disclosure attempt occurs there.  Lower it is, higher D 
should be.    
After that, Fig. 1b, C defines the hint h = H (s0), 
using some one-way hash function H, e.g., SHA256. 
We recall that in practice (i) h is unique for any s0 and 
(ii) it is impossible for good H such as the one 
mentioned, to calculate s0 as H-1(h). Next, C 
determines the backup hardness M. This parameter is 
the maximal number of match attempts H (s) =? h 
where each s is a different integer that could be s0, 
sufficient to find the successful match. Also, M is the 
owner’s expectation of the number of match attempts 
that 1-node site may perform at most in time D. Next, 
if there is no g = 1, 2… such that M = 2q, then C 
verifies whether the log2 M - bit long suffix r of s0 
is r < M. If not, then C chooses random q  I = [0, M[ 
and sets up r := q, i.e., substitutes q as new suffix r of 
s0, and recalculates both shares accordingly. Next, C 
calculates the bit-length of r, i.e., calculates an integer 
g such that either g = log2 M when such value exists, 
or g = log2 M. Then, C cuts off r from s0, i.e., 
produces the integer p = s0 \ 2g, where p denotes thus 
in fact the remaining prefix of s0 = p |r.     
As in [2], we call below each x a noise and I is the 
noise space. Then, f = p|0…0 is the base noise share, 
while s0 a noised one. The naming comes from the 
backup representation of s0 that is P = (p, h, M). P 
makes s0 hidden somewhere among M different noise 
shares, formed each as s = f + x ; x = 0,1..M -1, Fig. 
701

 
 1b. The noise shares form the noise share space, say 
Q, with card |Q| = card |I| = M. Each s is an integer, as 
we just said and can be s0. This happens iff x = r. The 
only known way to find out is to attempt the match. 
By the well-known properties of a good 1-way hash, 
this one succeeds iff s = s0.  The backup sent to the 
escrow is the couple (s1, P). 
Notice that, while the backup creation is quite 
similar to that in [2], the definition of noise shares 
differs. The rationale (that we do not plan to address 
further here) is a programmatically simpler discount 
calculation.    
III. DISCOUNT DEFINITION 
In [2], the full-cost recovery, i.e., using 
exclusively the backup as above defined, was the only 
capability of RENS schemes defined there. One may 
nevertheless observe that the requestor could also 
forward with the backup request some prior 
knowledge of s0 that could lower the recovery 
complexity. For instance, the key owner could 
observe that s0 is an odd integer. This would lower the 
complexity by 50%, as we show. We say that any 
such knowledge defines a discount, of 50% in this 
case.    
More precisely, the key owner defines the 
discount for a given backup according to an RENS 
scheme, by choosing some discount code. For what 
follows, the code is simply an m-bit suffix of the 
noised share s0 ; m = 0,1….Fig. 2. The value of m = 0 
tacitly means the no-discount request, i.e., the full-
 cost one. Otherwise, as we signaled already, we will 
talk about a discounted recovery. We expect for the 
latter m = 8 or m = 16 at most in practice. We call 
discount value the complexity reduction that the 
recovery with the code offers with respect to the full-
 cost. The analysis later on shows that the value of any 
m-bit long code is 2m for both, worst case and average 
complexities.  
The reason for such value is the 2m times smaller 
discounted (backup) hardness, i.e., the accordingly 
smaller maximal number of match attempts towards 
the successful one for sure. That discount with respect 
to M characterizing the full-cost recovery, is due to 
smaller noise space I’. That one becomes of size |I’| = 
M’ = M /2m, Fig. 2. We will show it in the sections 
that follow. Notice nevertheless already that the suffix 
r must be r = r’|d for some noise r’  I’. We expect 
accordingly in practice the reduction of the worst 
case, as well as of the average, complexity of up to 28 
= 256 for m = 8 and 216 = 64K times for m = 16.  
Discount codes that short may appear to the key 
owner as a single 16b Unicode digit or as one or two 
(extended) 8b ASCII digits, or as 2 ÷ 4 hex digits.  
One may expect them generally easy to retain, e.g., on 
a smartphone, or just in memory. Recall that 
Europeans are routinely trained to keep in mind their 
4-digit credit card codes.  
As the result that will appear, these codes may 
lower the recovery time 28 ÷ 16 times with respect to 
the full-cost timing for the same cloud size. 
Alternatively, they may reduce the cloud size by the 
same value, while keeping the same timing. The 
discounted hardness also allows combining both 
reductions.  Au finale, the discount decreases the 
cloud cost. Obviously, the necessary condition for a 
successful match attempt is that the noise share 
embeds the code provided.  The rationale for the 
discounted recovery algorithm we define in next 
section is to attempt matches only for such shares. 
Ex. 1. Key owner’s client key encryption 
generates s0 = ‘….0000 0000 0110 1010’. In Unicode 
the owner sees the 16b suffix above, qualifying for 
the discount code, as a single symbol ‘j’, hence we 
have : s0 = ‘….j’. In extended ASCII, the bits appear 
as two characters s0 = ‘….j’, where  denotes the 
NULL, i.e., ‘00’ character. Finally, the owner 
observes that s0 is an even integer. The owner retains 
as discount code representation for storage 
somewhere or simply for memory, the Unicode 
representation, i.e., ‘j’. Later, this same single 
character may represent either discount code: the 8b-
 long d = ‘0110 1010’ in ASCII and the 16b-long 
d = ‘0000 0000 0110 1010’. The owner may decide 
only when needed which discount to choose. The 
former will offer the discount value of 256 times, the 
latter will provide 64K times hardness reduction.  As 
2nd line protection against loosing even this simple 
code value, the owner retains that s0 is even. At the 
minimum, the code d = ‘0’ will still provide 50% 
discount, as it will appear. In the very last but not 
least, resort, the full-cost recovery is always feasible.    
RECOVERY  
A. Recovery Request 
The escrow performs the recovery upon the 
legitimate request. How the escrow knows which 
request is legitimate is out of scope here.  Recovery 
schemes with discount discussed below reuse the 
scheme for full-cost only recovery defined in [2] and 
[3]. The recovery request has in particular the same 
form, augmented however with the discount code.  It 
is thus formally the tuple Pd = (P, R, d). As for the 
full-cost only recovery request in [2], here, R 
designates the desired maximal recovery time, e.g., 10 
min. Recovery schemes in [2], as well as those below, 
consider then R as the upper bound on recovery 
computation time over any cloud node used.  They 
thus fulfill the user’s desire for sure provided the 
cloud overhead consisting of messaging, node 
allocation etc. times, is negligible.   
B. Full-Cost Recovery 
If the request has no discount, i.e., m = 0 in d, the 
escrow proceeds with the full-cost recovery. The 
schemes in [2] apply then as they are, except for the 
702

 
 revised s0 base noise share definitions.  The escrow 
forwards thus Pd to some cloud node C, called 
coordinator, with the exception of s1. In this way no 
cloud insider can disclose the recovered key.  
With respect to the actual execution on the cloud, 
managed by C, we recall now that [2] defines two 
basic schemes. We called them respectively static and 
scalable partitioning. The former was proposed for a 
homogenous cloud. The latter targets a heterogeneous 
one. Their common characteristic is that the recovery 
calculations attempt the matches over different noise 
shares f + m, until the successful match. This one 
must occur, but attempts may possibly explore even 
every m in I.  Both schemes partition the attempts 
over N nodes, with the linear speed-up O (N). The 
choice of N value depends on the scheme. In both 
cases, it makes the recovery computation at each node 
fitting the time bound provided by the requestor, e.g., 
10 mins. As the result, the whole calculation fits this 
bound. Typically, N should be possibly in thousands, 
as we discussed.  
The cloud delivers the noised share s0 found to the 
escrow. The escrow XORs it with s1 and, finally, 
delivers the key to the requestor.  
C. Discounted Recovery 
The discounted recovery request differs from the 
full-cost one by additional presence of the discount 
code with m > 0.  The cloud uses then the discounted 
recovery scheme that follows. Its rationale is that the 
noised share has to have d as m-bit long suffix, Fig. 2.  
The only noise shares in the noise share space that 
could match must have the same suffix. The recovery 
processing should generate all and only such shares. 
We say they form the reduced noise share space. The 
prefixes of noises in these shares, preceding suffix d 
in each noise, must form a subspace I’ with noises x = 
0,1,…M’ - 1 where M’ is M with d cut off from its 
binary representation. We call it reduced noise space. 
One may explore only this space. The exploration 
should form for each visited noise x, the noise x|d. It 
then should concatenate it then with prefix p of s0 to 
form noise share p|x|d, belonging to the reduced noise 
share space, for the match attempt. The successful 
match occurs when for some x, 
H (p|x|d) = H (p|r’|d) = h. See Fig. 2 for d = ‘j’. The 
exploration of I’ may use either partitioning scheme 
for full-cost recovery in [2] or [3]. The details of the 
scheme we sketch now follow these considerations. 
We explain it more and finalize its correctness proof 
afterwards.    
1) C calculates M’ = M \ 2m.   
2) For m > 0, Step (1) defines the reduced noise 
space I’ = [0, M’ [ we spoke about. C initiates the 
static or the scalable scheme for this space, i.e., uses 
M’ instead of M.  We recall that this step determines 
later N, in function of M’ and R. 
3) C delivers to each of N nodes the “usual” full-cost 
request for match attempts and the discount code d.  
The delivery is direct for the static scheme, and may 
be indirect for the scalable one, [2]. The scalable 
scheme determines N progressively, while 
propagating the request for match attempts.  
4) Each node n ; with n = 0,1…N - 1 for the static 
scheme and perhaps noncontiguous integers for n in 
some [0…N’[ where N’  N, for the scalable one, one 
first calculates the base share f’ for the discounted 
recovery. According to what we have said, we define 
it as the smallest possible with the suffix d, i.e. we 
clearly have f’ = ‘p |0’ + d.  Notice that f’ generalizes 
f for full-cost recovery, since f’ = f for m = 0.  
5) Next, using M’ instead of M, every node 
calculates one after another every value of noise x for 
which it should generate noise share s for match 
attempt H (s) =? h. For each x used, each node 
calculates s as s = f’ + x * 2m. The noises used at each 
node n depend on n and on the distribution scheme 
used, in the same way as for the full-cost recovery. 
Fig. 3 illustrates the issue that we address also in 
depth later in this section.  
6) As for the full-cost recovery, every node attempts 
the match for each s. If the match occurs, the node 
reports s as the noised share s0 to C, unless the node is 
C itself. The node terminates the service then, freeing 
all the resources.  
7) Otherwise, the node continues the attempts. It 
does so until the last relevant x or until the node 
receives the termination message from C. This one 
requests the node to terminate, i.e., to stop the service 
and free all the resources.   
8) Assuming the cloud finds in this way s0, C returns 
it to the escrow. The escrow XORs it with s1 and 
returns the recovered key to the requestor. C sends 
also out to the already mention termination message.  
For the static scheme it may send it simply directly to 
every node. It may alternatively send indirectly to 
most of the nodes, through the direct send-out to a 
few selected ones only that propagate it further in 
parallel. For the scalable scheme, the latter strategy is 
usually the only possibility. Space limits prevent 
dealing with more details.   
9) For m = 0, i.e., the full-cost recovery, C must get 
s0 or there is the failure of a cloud node or of the 
network connection between C and that node. One 
can reasonably expect such a failure to be very rare. 
We thus avoid discussing here the related details. 
Rules indicated for schemes without discount applies 
fully, besides.   
10)  For m > 0 in contrast, if C does not get s0 a new 
cause may be the invalid d that is different from the 
actual one in s0.  The legitimate requestor made 
perhaps an error, or the discount came from an 
intruder… As before, the cause may be also a cloud 
failure, as for m = 0.  C cannot distinguish from the 
above scheme between the cases. C acts then as if d 
703

 
 was invalid. The rationale is that this cause may be 
expected orders of magnitude more likely than the 
others. C reports to the escrow accordingly. It then 
terminates as discussed in Step 8.    
11)  As the result, we expect the requestor to usually 
send a different d. The whole algorithm restarts. Very 
rarely, the requestor may confirm nevertheless d as 
valid. C starts then a specific procedure. That one also 
restarts the recovery, but with additional features. 
These discriminate for sure at termination time 
whether there is a failure or d is invalid. The former 
case can still “hide” an invalid d. In the latter case, C 
reports to the escrow again that informs the recovery 
requestor accordingly. There are various ways to 
design that procedure.  All should be nevertheless 
more complex, hence more expensive, than the basic 
one above. Again, we cannot address the related 
details here. 
Discussion. Fig. 3 and Ex. 2 below illustrate the 
discounted recovery algorithm. The figure shows the 
distributed partitioned noise and noise share spaces 
over N nodes, for the discounted recovery using the 
static scheme and code ‘j’ from Ex. 1. The total size 
of the noise space and that of the noise share space is 
now M’. As for M for the full-cost recovery in [2], but 
for M’ here, a noise subspace on node n ; n = 0,1…N-
 1 ; contains each and every noise x < M’ and such that 
x mod N = n. The size of each noise subspace is M’ \ 
N or is M’ \ N + 1. The sizes of noise share subspaces 
at each node are accordingly the same.        
Fig. 3 and Ex. 2 illustrate the discounted recovery 
algorithm. The figure shows the distributed 
partitioned noise and noise share spaces over N nodes, 
for the discounted recovery using the static scheme 
and code ‘j’ from Ex. 1. The total size of the noise 
space and that of the noise share space is now M’. As 
for M for the full-cost recovery in [2], but for M’ here, 
a noise subspace on node n ; n = 0,1…N-1 ; contains 
each and every noise x < M’ and such that x mod N = 
n. The size of each noise subspace is M’ \ N or is M’ \ 
N + 1. The sizes of noise share subspaces at each 
node are accordingly the same.  
These sizes are in practice 2m times smaller for 
m > 0 than for M and the same N in [2]. It is the same 
for M’ with the same N and m = 0 and in the 
algorithm above, generating then the full-cost 
recovery. At each node, the discounted recovery has 
accordingly 2m times less match attempts to perform 
at worst for any m > 0, than for m = 0. This property 
leads to new possibilities for the recovery requestor 
aiming at best advantage of a discount. We address 
these issues in Section 5 below.  
Ex. 2. Consider M = 250 which should be rather 
typical. Suppose the noise shares 256b long, as an 
AES key. We have the base share (for the full-cost 
recovery) f = ‘p |0….0000’ with some prefix p and 
zero value suffix over 50 bits. Suppose further m = 2 
and d = ‘01’. C calculates M’ as M = 248. The base 
noise share for the discounted recovery is 
f’ = ‘p |0…00000000000|01’. Suppose the use of the 
static scheme and that after the calculations for M’ as 
in [2] for M, we have N = 1K, hence n = 0,1…1023.  
Node 0 attempts the matches for noises x = 0, 1024, 
2048…, i.e., with each successive x such that x mod N 
= 0 and till the largest such x < M’. Each x is 
multiplied by 22 then added to f’, then node 0 attempts 
the match of the resulting noise share, etc.  
In particular, node 0 always starts with the match 
attempt for s = f’. If no success, next attempt is for 
s = f’ + 1024*4, hence s = ‘p |0…010000000000|01’. 
Then, if needed, there is the attempt for 
s = f’ + 2048*4, i.e., s = ‘p |0…100000000000|01’ 
etc. Likewise, node 1, attempts the match for noise 
x = 1. Then, may continue for x = 1025, 2045…., i.e., 
where x mod N  = 1 and till the largest such x < M’. 
Node 1 starts thus with the attempt for s = f’ +1*4, 
i.e., s = ‘p |0…00000000001|01’. Perhaps continues 
then for s := s + 1024*4, i.e., s = f’ + 1025*4, that is 
for s = ‘p |0…10000000001|01’ etc. In general, as on 
Fig. 3, every node n attempts in this way the matches 
for each and only x < M’ that yields x mod N = n.  
The scalable partitioning has a more complex rule, 
see, e.g., [2] for it.  
With respect to Steps 10 & 11, the rationale for 
acting first as if d was invalid is easy to see. 
Assuming the use of a 1K-node cloud and the cloud 
sufficiently reliable to make a double failure among 
these nodes unlikely, the probability that a failure 
strikes just the node that should find s0 should 
normally be 1/1K. Everyone’s experience with PINs 
of credit cards, passwords…, shows errors once every 
relatively few uses, perhaps once every couple of 
dozens at most. The invalid d case should thus happen 
dozens of times more often.  
Next, observe that until the procedure in Step 11, 
the cloud acts in the same way for valid and invalid d. 
There is no way for C to distinguish between both 
upfront. An invalid d will thus cost the requestor 
more. This feature is intentional, expected to curb the 
discount tampering.   
The integer division ‘\’  by 2m amounts to m-bit 
right shift. Likewise, the multiplication by 2m 
performs the m-bit left shift. Dedicated shift functions 
may be faster than the arithmetic calculations. There 
are thus various ways to implement the algorithm we 
do not address further here. 
IV. ALGORITHM ANALYSIS 
A. Correctness 
Basically, it should appear that for every I, every f 
and every d, each RENS schema under consideration 
generates for every N the match attempts for all and 
only noise shares ending with d, in the noise share 
space generated by noise space I’. Also, no such share 
should be generated twice. Finally, it should appear 
that the recovery always terminates.   
704

 
 Proof. We skip the last part as quite obvious, at 
least in the absence of failures, here. The proof of the 
rest is rather easy to see from the figures and Ex. 2. 
We also skip the tedious details, referring the reader 
to [2], especially for the scalable scheme. The 
calculus of M’ obviously calculates the number of 
noises in I that terminates with d. This is the size of I’ 
hence of Q’. In Step (4), each node calculates f’ in the 
way that yields an integer being a noise share and 
such that (i) it ends with d and (ii) is greater than or 
equal to f. By definition this is f’. The loop at each 
node then attempts the matches using every noise x 
handled by the node. It should be clear from Fig. 3 
and the example that whatever is then N and d, all the 
M’ noises in I’ are possibly explored and only once 
per noise. Hence are all the noise shares in Q’ and H 
cannot map a share beyond Q’. The calculation of s in 
Step (4) produces clearly for each x the noise share 
ending with d. There cannot be such a share in the 
noise share space I (as well as in I’) missing from the 
distributed calculus. Also, one easily sees from Fig. 3 
that no noise shares in Q’ may be generated twice, 
whatever are the parameters there. Similar analysis 
holds for any partitioning that could be generated by 
the scalable scheme.    
Finally, it is easy to see that the termination 
protocol, i.e., the rules for cloud service termination 
without a cloud failure, is also correct. Every node 
starting the attempts indeed terminates. It either gets 
the termination message from C or terminates itself 
after all possible attempts. Next, C also terminates 
either by providing s0 or by finding an invalid d, as 
we discussed in Step 10. Finally, the recovery cannot 
produce in practice s0 for an invalid d. We prove this 
point in Section 4.3 below, as it rather concerns the 
safety.  
B. Complexity 
An m-bit long d decreases the recovery calculation 
complexity (hardness) 2m times in practice. 
Respectively, we have O (M / 2m) for the worst case 
and O (M / 2m + 1) on the average. 
Proof. For the full-cost recovery, the complexity 
could be measured basically by the number of noises 
to try out:  at most or on the average. Each noise may 
indeed trigger a match attempt. The computational 
cost of SHA256, as well as any other known good 1-
 way hash function dominated additional operations 
required, at the start-up or termination etc. of the 
algorithms. We had thus basically the complexity of 
O (M) in the worst case, for both static and scalable 
schemes. For both schemes, the discounted recovery 
has at most M’ noises to try out. This is 2m time 
smaller. On the other hand, the discounted recovery 
algorithm requires an additional initial calculation of 
M’. Next, it requires the calculation of f’. Finally, at 
each attempt, there is an additional multiplication by 
2m. However, it is the common knowledge that the 
cumulated computational cost of a few such 
operations is again negligible with respect to that of 
SHA256 or another good 1-way hash calculation.  
Hence, we have basically the O (M’) worst case 
complexity, i.e., the O (M / 2m) one. 
For the average case, we had under similar 
assumptions O (M / 2) for the full-cost recovery. The 
reason was that both schemes enumerated all attempts 
till the successful one, while every noise, hence every 
noise share tried out, were equally likely to try out 
and succeed, provided a good 1-way hash, as we 
supposed. For the discounted recovery, every attempt 
uses again a different noise and at worst all noises M’ 
noises are explored. The discount code is 
(pseudo)random, hence every code is equally likely.  
Also, the rest of s0, beyond the discount code, is 
(pseudo)random. Hence, every noise share generated 
is again equally likely to be the noised one, under the 
same good 1-way hash assumption.  We thus have on 
the average the O (M’ / 2) complexity, hence 
O (M / 2m + 1). 
Ex. 3 Consider the running example in [2] where 
the encryption complexity is set up so that 1-node 
recovery would require up to prohibitive 70-days and 
35 days on the average. To recover the key in 10 min 
at most instead, using the full-cost, a 10K-node wide 
cloud may do.  The actual cost could be 200$. 
Consider that the owner retained our 8b discount code 
‘j’, as in Ex. 1 and Fig. 3 previously discussed. Now, 
40-node cloud may suffice for the same timing. 
Alternatively, the same 10K cloud, delivers the 
discounted recovery in up to a couple of seconds. In 
both cases, the cost theoretically drops to less than 1$. 
A 16b discount ‘j’ would lower these figs accordingly 
further. The requestor could even recover the key at 
her/his own presumably single node, in about 2m1ins.  
C. Safety 
1) Knowledge of a discount code cannot lower the 
complexity of the requested backup under values 
O (M’) at worst and O (M’/2) on the average, 
provided by our algorithm (see below).  
Proof. Our algorithm enumerates all attempts till 
the successful one (if any). Every attempt uses a 
different noise among M’ and, at worst, all noises M’ 
noises are explored. The rest of s0, beyond the 
discount code, is (pseudo)random and thus 
independent of the discount code value. Also, for a 
good 1-way hash as we suppose, each such value is 
equally likely to generate the matching f’. Hence, 
whatever is a given a discount code, one cannot 
calculate from it or otherwise any f’ that could be less 
or more likely than any other possible. No method 
exists that would allow to attack the requested backup 
from its given discount, towards lowering the 
complexity under that of our algorithm. 
2) The recovery cannot produce in practice s0 for an 
invalid d.  
Proof. Indeed, any invalid d, say d’ here, is by 
definition different from the valid one. Hence the 
705

 
 share it defines, namely s = p|x’|d’, is a noise share 
different of s0.  As we discussed already, chance of 
having then H (s) = h are almost zero. Hence, in 
practice, no d’ may ever lead to a successful match. 
3) Guessing a discount code does not lower the 
complexity of any backup under O (M) 
Proof. See [4]. 
4) A discount code d for backup B does not lower the 
complexity of any discounted recovery using d for a 
different backup B’. The latter remains O (M) 
characterizing full-cost recovery of B’.  
Proof. The discount codes being pseudo-random, 
it would be indeed like guessing in (2).  
Property 3 means that the knowledge a discount 
code for a backup by the escrow, does not threaten 
any different backup at escrow’s possession.  A 
discount code once used by the escrow is thus of no 
further utility.    
V. MULTI-SHARE NOISED SECRET 
SHARING 
A. Rationale 
The above discussed schemes used at the basis the 
2-share secret sharing. Share s0 was then noised, 
resulting in the, so-called, 2-share noised secret 
sharing. Complexity analysis sketched above and 
discussed in depth in [3], has shown that the 2-share 
noised secret sharing noised secret sharing schemes, 
for any given full-cost maximal recovery time R, 
provide the expected (full-cost) recovery time E (R ) 
equal to at most R/2. The static scheme provides 
exactly that expected value, while the scalable one 
may provide slightly less. These values are immediate 
and easy to spot consequences of the O (M / 2) 
average full-cost complexity for the static scheme.  
One rationale of these properties is a uniform 
distribution of the suffix r (or r’) of the noised share 
within I or I’ for m > 0. One consequence is that for 
any probability p, the recovery time may be over (1-
 p) R. For instance for p = 10%, it would be at least 
0.9R, i.e., almost twice as big as the user could expect 
most likely. By the same token, it could be also under 
0.1R. The cloud costs would be in accordance. Some 
users may be expected to feel uneasy with such a 
relatively likely perspective of the almost double bill. 
In turn, intruders may feel attracted to gamble over 
the uniformly likely perspective of the cheaper that on 
the average disclosure.   In both cases, there is room 
for schemes where R is closer at will to E (R ). As it 
will appear, this is the property of the (k + 1) – share 
noised secret sharing schemes we introduce now.  
These schemes generalize the schemes above, 
assimilated to k = 1, towards larger k values k = 
2,3,4…  We keep the notation from Section 2 and 
after, adding eventually obvious indices.  
B. Backup Creation 
To start, O chooses k and, as before, the 
prohibitive 1-node recovery time D. The rationale for 
“best” choice of k will appear soon. Next, O defines a 
(usual) (k + 1) – share secret with thus the random 
shares s0…sk-1 and sk = K XOR s0 XOR s1… XOR sk-1. 
Each sj  ; j = 0…k-1 ; has the same structure as s0 
above, namely sj = pj |rj. Every suffix rj is also as 
before adjusted to be under the size of the noise space 
M, if the need occurs. We provide soon the way to 
define M that slightly differs from the previous one. O 
computes then k hints h0… hk-1, where hj = H (sj) for 
every j. A match attempt for any noise x, to be 
performed during the recovery, will consist of the 
calculation H (fj + x) ?= hj for specific j.  
It may occur that all the noises and hints are 
explored for a successful full-cost recovery. To 
choose then M conform to D, O starts with the 
measure or an estimate of the throughput T that is the 
number of 1-node match attempts per time unit, 
basically a second. Then M is chosen as M = D T / k. 
Indeed, for every M, there are k M match attempts 
possible. Hence D = k M / T. Note that for k = 1 the M 
choice is compatible with that above for the 2-share 
noised secret sharing.  Next, O forms P that is now P 
=  (p0…pk-1, h0…hk-1, M). Finally, O sends out the 
couple (sk, P) as the K backup. O retains also the 
vector d = (d0…dk-1) as the discount code, where 
every dj spans (the same) number m of the suffix bits 
of its sj.   
C. Recovery 
To recover K, the legitimate user sends out the 
request Pd = (P, R, d). Escrow sends then to the cloud 
all the backup data except for sk. The match attempts 
split over the N cloud nodes, as before, Fig. 4, using 
the static or the scalable scheme. For the latter 
scheme, the coordinator defines N as N = k M’ / T R. 
The rationale is first that for every noise x’ within the 
reduced noise space, i.e., x’ = 0,…,M’ – 1, the node in 
charge of attempting the matches for some x 
embedding x’, i.e., for some dj within d we have x 
= x’|dj, has in fact k such match attempts to generate. 
These are all the attempts H (fj + x) = H (fj + x’|dj ) ?= 
hj  for every j = 0…k – 1. Notice that up to now we 
had k = 1 only, hence a single match attempt for every 
x’.  Next, to meet the R bound, the node has to 
perform at most R T attempts, assuming that all the 
nodes provide the same throughput (a homogeneous 
cloud). On the other hand, with the already discussed 
hash partitioning, the node performs in practice 
k M’ / N attempts. Hence, we have k M’ / N  R T. 
The coordinator of the static scheme chooses the 
minimal possible N that is the one above. The 
scalable scheme generates N in a more involved way. 
The cloud is supposed heterogeneous, we recall, 
hence T may vary among nodes. The calculus is then 
distributed among the nodes as we mentioned already. 
706

 
 The N finally generated is usually somehow larger 
than the size-optimal one, [2].  
Regardless of the partitioning scheme, every node 
attempts the matches for each y assigned to it as 
already discussed. Every node determining x for some 
hj, i.e., encountering a successful match, reports the 
share sj = fj + x to the coordinator. Once the 
coordinator gets every expected sj, it reports them to 
the escrow. That one performs the XORing of all of 
them with sk and sends the recovered secret, i.e. K, to 
the user. As for k = 1 above, the full-cost recovery 
must normally (without any cloud infrastructure 
failure) succeed for every k. A discounted one 
accordingly always succeeds in practice for a valid 
discount code and always fails otherwise.   
D. Discussion 
The recovery computation has obviously the 
maximal complexity O (M’), for every k. The average 
one is now O (M’ k / (k + 1)). Accordingly, the 
average recovery calculation time is R * k / (k + 1).  
The value k / (k + 1) is known as the average value of 
the largest randomly chosen value in interval [0, 1[, 
among k such choices. Obviously it increases towards 
1 with k. For the 2-share noised secret sharing we 
match the already discussed values O (M’ / 2) and 
R / 2. For higher k, both raise up towards M’ and R’ 
respectively. For instance, if O chooses a 6-share 
secret sharing, hence k =5, and the recovery requestor 
U expects a 5-minute recovery, U may choose 
R = 6 min. Instead of choosing R = 10 min for a 2-
 share only scheme. A perhaps up to 40% lower cloud 
bill in consequence. Also, the probability of the 
recovery time being within some fraction yR is now yk 
instead of only y for a 2-share only scheme.  Hence, 
in our example, it is 10-5 instead of 10-1 only. One 
may expect thus to deter much more strongly any 
gambling temptations of an insider on the escrow site.  
A possible inconvenient of a larger k may be a k 
times longer d. The key owner wishing to only 
memorize it, as one does it for the credit card, may 
have trouble for k > 3. A way out may be parts of a 
one-way hash of a code phrase. That one should be, 
for the owner, easy to remember or reconstruct. It 
should also be harder to crack by known tools than a 
full-cost recovery itself. This can result, as usual for 
passwords, from mix of letters, numbers and special 
characters. It could be as easy nevertheless as, e.g., 
“In Jan. 1950 my age was 3.5 years”.  For, say, 1B 
discount code per share and our k = 5, any five bytes 
of the hash could do. The generation of the k pseudo-
 random shares should be amended consequently. 
There are various easy ways to do it.          
VI. RELATED WORK 
The basis for the work above is the static and the 
scalable schemes in [2]. These schemes use both hash 
partitioning. In [3], one proposes also an RENS 
scheme using the range partitioning. Our discounted 
recovery calculation may be expected applying to this 
scheme as well.  Another scheme in [3], noises 
multiple shares, i.e., it provides the (k + 1)-share 
noised secret sharing with k > 1, like we do in Section 
5. However, whether that scheme may be generalized 
to support discounts is at present an open question.   
Besides, we are not aware of any other related 
work specific to some kind of discounted recovery. 
The work related to the noised secret schemes in 
general, including the overview of various proposals 
for key recovery, is extensively discussed in [2] and 
in [3]. We thus avoid repeating it here. We only 
notice however that a bird’s eye view may assimilate 
a discount code to a particularly easy to use trapdoor 
decryption function dm, of bit-length m. The “power” 
of successive functions for a key: d1, d2… scales up 
then exponentially with m.  
VII. CONCLUSION 
Discounts appear a potentially highly useful 
capability for an RENS scheme. The existing 2-share 
schemes generalize towards discount management 
easily. The key becomes “never-lost”, with (illegal) 
disclosure cumbersome at will for the attacker and yet 
with cheap (legal) and practical recovery by the 
discount possessor. This combination, unique up to 
now for a key recovery scheme, has the potential to 
offset the current fears of key loss. On the one hand, 
our schemes may help users managing sensitive data 
purely locally, but fearing key loss or data disclosure 
anyhow. On the other hand, they may aid those 
attracted by big data outsourcing. Who remained 
deterred up to now, by fears of accordingly big 
consequences of key loss, or, by perhaps equally 
calamitous consequences of cloud content disclosure.  
With respect to the work in progress, we continue 
the analysis of our schemes. We further plan to 
extend it to other schemes in [3].   
 
 [1] ARO Meeting on Cloud Security. GMU March 11-
 12,2013. http://csis.gmu.edu/albanese/events/march-2013-cloud-
 security-meeting/ . 
 [2] Jajodia, S., Litwin, W., Schwarz, Th., S.J. Recoverable 
Encryption through a Noised Secret over a Large Cloud. 5th Inl. 
Conf. on Data Management in Cloud, Grid and P2P Systems 
(Globe 2012 ). Springer Verlag, Lecture Notes in Comp. Sc. 
[3] Jajodia, S., Litwin, W., Schwarz, Th., S.J. Recoverable 
Encryption through a Noised Secret over a Large Cloud. Intl. 
Journal on Large-Scale Data and Knowledge-Centered Systems, 
TLDKS IX, LNCS 7980, 2013.  
[4] Jajodia, S., Litwin, W., Schwarz, Th., S.J. Key Recovery 
Using Noised Secret Sharing with Discounts and Large Clouds. 
Lamsade Research Report. July 2013 
http://www.lamsade.dauphine.fr/~litwin/cours98/CoursBD/Key%2
 0Recovery%20with%20Discounts%20Res%20Rep.pdf 
[5] Raluca Ada Popa, Redfield, C., Zeldovich, N. & 
Balakrishnan, H. CryptDB: Protecting Confidentiality with 
Encrypted Query Processing. SOSP ’11, October 23–26, 2011, 
Cascais, Portugal. 
 [6] Smith, K. How Practical Is Computable Encryption? In[1]. 

 707
