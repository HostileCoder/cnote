Construction of Exact-BASIC Codes for Distributed
 Storage Systems at the MSR Point
 Hanxu Hou ¤, Kenneth W. Shumà and Hui Li 
  Shenzhen Eng. Lab of Converged Networks Technology, Shenzhen Key Lab of Cloud Computing Tech. and App.,
 Peking University Shenzhen Graduate School
 à Institute of Network Coding, the Chinese University of Hong Kong
 ¤ Department of Information Engineering, the Chinese University of Hong Kong
 AbstractÑRegenerating codes (RGC) are a class of distributed
 storage codes that can provide efficient repair of failure nodes in
 distributed storage systems. In general, the reduction of repair
 bandwidth of RGC is at the expense of a small increase in
 storage cost and computational cost. The high computational
 complexity of data coding over a finite field of large size makes
 it unsuitable for practical distributed storage systems. BASIC
 codes, which stands for Binary Addition and Shift Implementable
 Convolutional codes, is introduced in [1] with the aim of reducing
 computational complexity, while retaining the benefits of RGC. In
 this paper, we present a construction of exact-repair BASIC codes
 at the minimum-storage point (MSR). A helper node needs no
 coding to repair a failure node for the minimum-storage BASIC
 codes. The results of simulation show minimum-storage BASIC
 codes outperform Cauchy Reed-Solomon codes in both repairing
 cost and coding cost.
 I. INTRODUCTION
 Distributed storage systems achieve high reliability by stor-
 ing the big data redundantly in a large collection of unreliable
 storage nodes. There are two ways of providing redundancy.
 The simplest form of redundancy is replicate the data multiple
 times, which is widely used in many practical storage systems,
 e.g., Google file system [2] and Facebook data centers [3]. As
 a generation of replication, erasure code can provide much
 better storage efficiency than replication, and Reed-Solomon
 (RS) code is a typical erasure code. The original file can be
 recovered from any set of k storage nodes, and we term this
 property as MDS (Maximum Distance Separable) property. To
 repair a failed node, RS code will let the new node download k
 coded pieces from the surviving nodes, reconstruct the original
 file and compute the lost piece. Call this process as repairing
 process, and repair bandwidth is the total network bandwidth
 of a repairing process. The repair bandwidth of RS code is k
 times of size of the lost piece, which is a waste of network
 bandwidth,
 This work was partially supported by National Basic Research Program
 of China (973 Program, No.2012CB315904), National Natural Science Foun-
 dation of China (No.NSFC61179028), SZ JCYJ20130331144502026, Guang-
 dong Natural Science Foundation (GDNSF, No.S2011010000923) and a grant
 from University Grants Committee of the Hong Kong Special Administrative
 Region, China (Project No. AoE/E-02/08).
 The performance of both redundancy-reliability and repair
 problem was formulated and studied in [4], which is called
 regenerating codes (RGC). Consider an (n, k, d, ?, ?) regen-
 erating code that the file of size B is stored in a distributed
 storage system with n storage nodes, where each node stores
 ? packets. All k? packets of k storage nodes are downloaded
 by a data collector (DC) to reconstruct the object, this process
 is termed as reconstructing process and the total data down-
 loaded of the process is the reconstructing bandwidth. If a
 storage node has failed, a new storage node can regenerate
 the ? packets by downloading ? packets each from any d
 surviving nodes. After that, a DC can still reconstruct the
 original object by downloading all the k? packets from any k
 storage nodes. In this repairing process, the repair bandwidth
 of RGC is ? = d?, and the number of nodes accesses d is
 reffered to as repair-degree.
 RGC possess an optimal tradeoff curve between the amount
 of reconstructing bandwidth k? and the repair bandwidth d?.
 Two kinds of optimal codes, the minimum-storage regenerat-
 ing (MSR) point and the minimum-bandwidth regenerating
 (MBR) point are proposed in [4], where MSR codes are
 corresponding to the point with k?MSR = B, ?MSR =
 Bd
 k(d?k+1) , and MBR codes are corresponding to the point
 with ?MBR = 2Bd2kd?k2+k , ?MBR =
 2Md
 2kd?k2+k . The explicit
 constructions of MSR codes and MBR codes are developed
 in [5]Ð[7]. Up to now, the best results are the constructions of
 MSR codes and MBR codes in [7], which achieve the optimal
 tradeoff at the MSR codes (n ² 2k) and MBR codes (all n
 and k) using the product-matrix construction.
 With respect to the repairing process and coding process,
 there are arguably several performance merits possible in the
 design-space of codes for distributed networked storage:
 1) Repair bandwidth. MBR codes are able to achieve the
 minimum repair bandwidth and PM (product-matrix) [7]
 is a typical construction, but take an order of magnitude
 more computation time than standard erasure codes for
 both encoding and decoding [8].
 2) Repair-degree. Recently proposed SRC (self-repairing
 codes) [9], [10] achieve this optimal, by allowing one
 repair while contacting only two nodes, as long as less
 4235"KGGG"Kpvgtpcvkqpcn"Eqphgtgpeg"qp"Dki"Fcvc"
 55978-1-4799-1293-3/13/$31.00 ©2013  IEEE 
than half of the nodes have failed. This is at the price
 of sacrificing the MDS property.
 3) Input/output (I/O) cost, which measures the number of
 bits a storage node needs to read out from its memory
 in order to repair the failed node. In the extreme case
 where I/O cost is minimal, the number of bits read out
 from the memory is exactly equal to the number of bits
 to be sent out. Data combining is only required in the
 receiving end. RGC with minimal I/O cost is called a
 repair-by-transfer regenerating code. The construction of
 repair-by-transfer minimum-repair-bandwidth regenerat-
 ing codes can be found in DRESS codes [11].
 4) Computation complexity. Traditionally, RS codes and
 RGC are constructed based on finite field GF(q), where
 q > 2. So we have to handle multiplication operations
 during coding and repairing process, results in more
 computation complexity.
 RGC outperform RS codes in terms of repair bandwidth,
 but take an order of magnitude more computation time than
 standard erasure codes for both encoding and decoding [12].
 More accurately, [12] gives a system perspective of regener-
 ating codes and clam that product-matrix codes [7] are good
 candidates among RGC for replacing RS codes but still with
 7 times of the encoding costs when compared to systematic
 RS codes and more decoding time compared to RS codes.
 BASIC (Binary Addition and Shift Implementable Convolu-
 tional) codes is proposed in [1] that can achieve all the benefit
 of RGC with only addition and shift operations involved in
 coding process. The computational complexity of BASIC code
 is much less that of RGC [1]. The source packets of BASIC
 codes can also be recovered using ZigZag decoding [13] if
 we choose the encoding coefficient which has the increasing
 difference property. In this paper, we give construction of
 exact minimum storage BASIC codes. A helper node needs
 no coding to repair a failure node, the proposed codes are
 repair-by-transfer minimum storage BASIC codes.
 A similar regenerating codes is presented in [6]. The dif-
 ferences of the codes in this paper and in [6] are as follows.
 First, the operations in mixing the data packets are different.
 Multiplication and addition are involved in [6], while shift
 and addition are involved in this paper. Second, to reduce
 complexity, the encoding coefficient of [6] in different nodes
 are the same, but just shifted some positions. The encoding
 coefficient of the minimum storage BASIC codes in different
 nodes can be different and do not impact the complexity.
 The paper is organized as follows. In section II, we will
 review some definitions and results of BASIC codes. The
 construction of minimum storage BASIC codes is proposed
 in section III. In section IV, we evaluate the complexity of
 BASIC codes. We implement the proposed minimum storage
 BASIC codes in section V, and the results of simulation show
 that the proposed minimum storage BASIC codes outperform
 Cauchy Reed-Solomon codes (which is widely used in practi-
 cal storage systems) in both repairing cost and decoding cost.
 Finally, we conclude with the main contributions and results
 of our paper in Section VI.
 II. BASIC CODES
 A. Definitions of BASIC Codes
 BASIC codes [1]: can achieve the full benefit of regenerat-
 ing codes with only shift and addition operations be involved
 in both encoding and decoding process. Many expensive
 multiplications of finite field can be avoided.
 Similar to RGC [4], there exist an optimal tradeoff curve
 between ? and ?. We term codes that attain two extremal
 points of the best storage efficiency and the minimum re-
 pair bandwidth as minimum-storage (MS) BASIC codes and
 minimum-bandwidth (MB) BASIC codes, respectively.
 Two main versions of repair have been considered in [4]:
 exact repair and functional repair. In exact repair, the failed
 data packets are exactly regenerated, thus restoring exactly the
 lost encoded packets with their exact replicas. In functional
 repair, the requirement is relaxed: the newly generated packets
 can contain different data from that of the failed node as long
 as the repaired system maintains the MDS property. We term
 BASIC codes with exact repair, functional repair as exact-
 BASIC codes and functional-BASIC codes respectively.
 B. Design Framework
 In the encoding process of BASIC codes, the source data
 file is divided into B data packets with size L bits. Similar to
 [1], we represent the bits of a packet by the coefficients of a
 formal power series [14](p.154). A formal power series over
 GF (2) is a formal sum
 °·
 j=0
 cjzj = c0 + c1z + c2z2 + c3z3 + . . . ,
 where z is an indeterminate and cj are elements in GF (2). By
 Òa node stores a power seriesÓ, we mean that the coefficients
 of the power series are stored. In practice, the number of bits
 stored in a node is finite, and the power series is a polynomial
 with finitely many non-zero coefficients.
 There is no convergence issue in formal power series,
 because a formal power series can be regarded as an infinite
 sequence of bits (c0, c1, c2, c3, . . .), with the indeterminate z
 being the right shift operator. The addition of two infinite
 sequences (cj)°j=0 and (dj)°j=0 are performed componentwise,
 and the multiplication is defined by ÒconvolutionÓ,
 (cj)°j=0 á (dj)°j=0 = (ej)°j=0
 with
 ej =
 j·
 =0
 cdj?.
 The set of all formal power series thus form a commutative
 ring with identity, and is denoted by GF (2)[[z]].
 For i = 1, 2, á á á , k, we denote the k data packets as si(z).
 Define a coded packet as a linear combination of the data
 packets, with coefficients which is either 0 or a power of z.
 The coded packet is obtained by shifting the power series to
 the right appropriately and adding the resulting power series.
 34
For i = 1, 2, á á á , n, a coded packet is denoted by pi(z) that
 can be written in the form
 pi(z) = ci,1(z)s1(z) + ci,2(z)s2(z) + á á á+ ci,k(z)sk(z),
 where ci,j(z) belongs to a subset of GF (2)[[z]] that the
 element of the subset is either 0 or a power of z, and denote
 this subset as C. When ci,j(z) is nonzero, the exponent of
 ci,j(z) stand for the number of added bits at the head of
 the packet sj(z) for the coded packet pi(z). The encoding
 is completely specified by ci,j(z) for i = 1, 2, . . . , n and
 j = 1, 2, . . . , k. We define the encoding matrix E as the n?k
 matrix whose (i, j)-entry is equal to ci,j(z). If we put the
 coded packets together in a column vector, we have?
 ????
 p1(z)
 p2(z)
 .
 .
 .
 pn(z)
 ?
 ???? = E á
 ?
 ????
 s1(z)
 s2(z)
 .
 .
 .
 sk(z).
 ?
 ????
 We say that the MDS property is satisfied if we can recover
 the data packets s1(z), s2(z), á á á , sk(z) from any k coded
 packets in
 {p1(z), p2(z), á á á , pn(z)}.
 Example: Let k = 3, n = 6. There are three data packets
 s1(z), s2(z) and s3(z). The coded packets are defined as
 p1(z) = s1(z), p2(z) = s2(z), p3(z) = s3(z)
 p4(z) = zs1(z) + s2(z) + s3(z)
 p5(z) = s1(z) + zs2(z) + s3(z)
 p6(z) = s1(z) + s2(z) + zs3(z).
 The corresponding encoding matrix of the coded packets is
 E =
 ?
 ???????
 1 0 0
 0 1 0
 0 0 1
 z 1 1
 1 z 1
 1 1 z
 ?
 ??????? . (1)
 Proposition 1. [1] Suppose that s1(z) to sk(z) are data
 packets, and p1(z) to pn(z) are n coded packets with global
 encoding vectors v1 to vn, respectively. Let {i1, i2, á á á , ik} be
 any subset of {1, 2, á á á , n} and D be the sub-matrix of E ob-
 tained by retaining rows i1 to ik. Then we can compute s1(z)
 to sk(z) from the k coded packets pi1(z), pi2(z), á á á , pik(z)
 if the determinant of D is nonzero.
 Proof. We give a sketch of proof for the sake of completeness.
 Write det(D) as ze(1 + f(z)), where e is a non-negative
 integer and f(z) is a polynomial with zero constant term. The
 inverse of 1+ f(z) is 1+ f(z) + f(z)2 + f(z)3 + á á á , which
 is considered as a formal power series. Recall that the adjoint
 of D, denoted by adj(D), is defined as the transpose of the
 matrix of cofactors of D [15](p.20). We get?
 ????
 s1(z)
 s2(z)
 .
 .
 .
 sk(z)
 ?
 ???? = 1 + f(z) + f(z)2 + á á áze á adj(D) á
 ?
 ????
 pi1(z)
 pi2(z)
 .
 .
 .
 pik(z).
 ?
 ????
 Note that the power series in the numerator is the multiplica-
 tive inverse of 1 + f(z) in GF (2)[[z]], and is well-defined,
 because each coefficients can be obtained with finitely many
 arithmetic operations.
 Conversely, if det(D) = 0, then the rank of D is strictly
 less than k. Hence we can not solve for s1(z) to sk(z).
 For example, the determinant of all 3 ? 3 sub-matrices of
 the encoding matrix E in (1) are 1, z, z+1, z2+1, z3+z, and
 are all nonzero. Hence this matrix satisfies the MDS property.
 III. CONSTRUCTION OF MS-BASIC CODES
 It is shown in [7] that if we can construct an (n, k, d)
 optimal regenerating code with ? = 1, then we can construct
 an (n, k, d) optimal regenerating code with integer ? > 1. To
 simplify the system implementation, we can assume ? = 1.
 Then,
 ?MS = d? k + 1, (2)
 BMS = k(d? k + 1), (3)
 A. Code Construction
 An (n, k, d) MS-BASIC code is composed of n storage
 nodes, denoted by {N1, N2, á á á , Nn}, and satisfying the fol-
 lowing two conditions:
 ¥ d = k + 1.
 ¥ B = n.
 Therefore, by equation (3), they will also satisfy that ?MS = 2
 and B = n = 2k.
 The encoding of MS-BASIC codes are as follows:
 ¥ Fragment the file into B = n data packets
 s1(z), s2(z), á á á , sn(z) equally, term these original pack-
 ets as data packets.
 ¥ Construct n parity-check packets p1(z), p2(z), á á á , pn(z)
 by
 pi(z) =
 k+i·
 j=i+1
 ci,j(z)sj(z), i = 1, 2, á á á , n, (4)
 ¥ Store (si(z), pi(z)) in the node Ni for i = 1, 2, á á á , n.
 Where the addition in (4) is mod n addition. In the above
 encoding process, ci,j(z) is chosen in the set C such that the
 encoding matrix of any k nodes satisfies MDS property. The
 coded packets mentioned in the section II include data packets
 and parity-check packets. In general, the parity-check packets
 are generated by (4),
 35
B. Node Regeneration
 A failed node can be repaired by the following two steps:
 1) Download the data packets from the next k nodes in
 the sequence. Note that the next node of Nn is N1.
 From these data packets, the parity-check packet of
 the newcomer can be calculated.
 2) Download the parity-check packet from the previous
 node in the sequence. Solving an easy system of
 equations, the data packet of the newcomer can be
 obtained.
 It is clear that MS-BASIC codes achieve bandwidth optimality
 for parameter d = k+1 and B = n, by equations (2) and (3).
 Moreover, note that the failed node have to be regenerated by
 a specific subset of d = k + 1 nodes, not any d nodes.
 C. Data Reconstruction
 We can check that a DC can reconstruct the original object
 by downloading two packets of any k storage nodes. For any
 k nodes, we can retrieve k data packets and k parity-check
 packets which a linear combination of k data packets. The
 other k data packets can be retrieved using the method of
 Proposition 1 from k parity-check packets. Of course, we
 can also retrieve the other k data packets using the ZigZag
 decoding method if the corresponding encoding coefficients
 satisfy the increasing difference property [13]. However, if the
 encoding coefficients do not satisfy the increasing difference
 property, the ZigZag decoding method does not work.
 D. Example
 In this subsection, we will describe the construction of a (6,
 3, 4) MS-BASIC code.
 First, the file is fragmented into B = n = 6 data packets
 s1(z), s2(z), á á á , s6(z). Then, two packets si(z) and pi(z)
 are stored in node Ni, where pi(z) is computed using the
 following form:
 pi(z) =
 3+i·
 j=i+1
 ci,j(z)sj(z), i = 1, 2, á á á , 6,
 and ci,j(z) is given as:
 (c1,2(z), c1,3(z), c1,4(z))
 = (c4,5(z), c4,6(z), c4,1(z)) = (z0, z1, z2),
 (c2,3(z), c2,4(z), c2,5(z))
 = (c5,6(z), c5,1(z), c5,2(z)) = (z0, z2, z1),
 (c3,4(z), c3,5(z), c3,6(z))
 = (c6,1(z), c6,2(z), c6,3(z)) = (z0, z0, z0).
 For (6, 3, 4) MS-BASIC code, we can repair one failure
 node by connecting to 4 nodes and downloading one packet
 from each of 4 helping nodes. The repairing process of node
 1 is showed in Fig. 1. The new node download 4 packets
 s2(z), s3(z), s3(z), and s1(z) + s2(z) + s3(z) from nodes
 2, 3, 4 and 6 respectively. The two stored packets of node 1
 s1(z)
 s2(z)+zs3(z)
 +z2s4(z)
 N1 N2 N3 N4 N5 N6
 s2(z) s3(z) s4(z) s5(z) s6(z)
 s3(z)+z2s4(z
 )+zs5(z)
 s4(z)+ 
s5(z)+ s6(z)
 s5(z)+zs6(z)
 + z2s1(z)
 s6(z)+z2s1(z
 )+ zs2(z)
 s1(z)+ 
s2(z)+ s3(z)
 z z2
 s1(z)s2(z)+zs3(z)+z2s4(z)
 New 
node
 Fig. 1: The distribution of data packets and redundancy packets
 of (6, 3, 4) MS-BASIC code. The new node can download 4
 packets s2(z), s3(z), s3(z), and s1(z)+s2(z)+s3(z) and add
 some shifted packets to repair node 1.
 can be regenerated by some simple additions and right-shifts
 of 4 downloaded packets. The parity-check packet of node 1
 s2(z) + zs3(z) + z2s4(z) can be repaired by adding the data
 packet s2(z), one-shift data packet s3(z) and two-shift data
 packet s4(z). The data packet s1(z) can be repaired by the
 following equation:
 s1(z) = (s1(z) + s2(z) + s3(z)) + s2(z) + s3(z).
 We can check that a DC can reconstruct the original
 object by downloading two packets from any 3 storage nodes.
 Suppose a DC connects to nodes 1, 2 and 3, and down-
 load 3 data packets s1(z), s2(z), s3(z) and 3 parity-check
 packets s2(z) + zs3(z) + z2s4(z), s3(z) + z2s4(z) + zs5(z),
 s4(z) + s5(z) + s6(z). One can retrieve z2s4(z) by adding
 s2(z), one right-shift of s3(z) and s2(z) + zs3(z) + z2s4(z),
 and we can get the data packet s4(z) by shifting two bits of
 z2s4(z). The other data packets s5(z) and s6(z) can also be
 decoded similarly.
 IV. OVERHEAD RATIO AND COMPLEXITY
 Due to bitwise shifting, the length of the coded packet is L
 plus the maximal degree of the global encoding coefficients.
 The maximal degree r of the coefficients is thus the storage
 overhead. The size of each packet in (n, k, d) MS-BASIC
 codes is p = L + r bits, where r is the maximal degree.
 This overhead is negligible when the packet size L is large.
 In (n, k, d) MS-BASIC codes, each node stores one data
 packet and one parity-check packet. Each parity-check packet
 is a linear combination of k data packets, which requires k?1
 additions of p bits. So, the encoding computational complexity
 of (n, k, d) MS-BASIC codes is O(nkp).
 In the repairing process of (n, k, d) MS-BASIC codes, both
 the data packet and the parity-check packet can be regenerated
 by summing k packets. So, the repairing process needs 2k
 36
additions of p bits. The repairing computational complexity
 of (n, k, d) MS-BASIC codes is O(kp).
 If DC connects to k consecutive nodes, each parity-check
 packet can be retrieved by adding k packets and there are
 k parity-check packets. The complexity of decoding k con-
 secutive nodes is O(k2p). If the k nodes are not continuous,
 to reconstruct the original file, DC first need to compute
 the inverse matrix of the encoding matrix, then multiply
 the inverse matrix by the coded packets. Compared to the
 computing time of large amounts of data, the time of compute
 the inverse matrix is very small, and we do not consider it.
 The multiplication of the inverse matrix and k parity-check
 packets takes O(k2) additions. Therefore, the complexity of
 (n, k, d) MS-BASIC codes is O(k2p).
 Remarks: It is more convenient to perform byte-wise shift
 instead of bit-wise shift. Also, it is not necessary to physically
 shift the bits in the memory. By creating pointers to the
 data bits, the shifting operations are performed by simply
 incrementing the pointers.
 V. EVALUATION
 Cauchy Reed-Solomon (CRS) codes [16] were proposed by
 Blomer et al. in 1995 to improve the performance of encoding
 complexity using Cauchy distribution matrix. Since then, CRS
 codes are widely used in communication and storage systems.
 To evaluate the practicality of the proposed MS-BASIC codes,
 in this section, we provide details on the experiments we
 performed to evaluate the performances of MS-BASIC codes
 and CRS codes. There are many versions of implementation
 of CRS codes, and Jerasure library [17] is considered to be
 one of the most practical version that can achieve the optimal
 encoding performance. We select this implementation version
 of CRS codes and select the word size of CRS codes to be 16
 bits. The machine for testing has a 1GHz single-core processor,
 1GB of RAM and 20GB of Hard Disk. It runs CentOS Linux,
 version 5.6 on VMware Workstation.
 All the experiments have been done for two different files
 of 78.4MByte and 440MByte in size respectively, with the pa-
 rameters (n, k) to be (6, 12), (8, 16) and (10, 20) respectively.
 In total, three experiments (encoding time, repairing time and
 decoding time) were performed on the above setup. Each data
 point in the graphs that follow is the average of five runs.
 A. Encoding Time
 In the encoding process of MS-BASIC codes, a data file of
 M bits is first divided into n data packets, each of M
 n
 bits,
 we assume M is divisible by n. Then we generate n parity-
 check packets according to (4). Each of n nodes stores one
 data packet and one parity-check packet.
 For CRS codes, the data file of M bits is divided into many
 pieces, each of kw bits. Then divide each piece into k data
 packets with the same size w bits. Each k data packets can be
 used to generate n ? k parity-check packets. Each node will
 store one packet for each piece. Note that the n ? k parity-
 check packets generated by CRS codes using a (n ? k) ? k
 Cauchy distribution matrix that is defined over the Galois Field
 GF (2w) [17]. The (n ? k) ? k Cauchy distribution matrix
 over GF (2w) is next converted into a w(n? k)?wk binary
 distribution matrix using a projection defined by a primitive
 polynomial of GF (2w) [16]. Fig. 2 displays the encoding
 process of parity-check packets for CRS codes with n = 6,
 k = 4 and w = 3. With binary distribution matrix, one may
 create a parity-check packet as the XOR of all data packets
 whose corresponding columns of the binary distribution matrix
 have ones. Note that the expensive matrix multiplication is
 replaced by binary addition. So this is a great improvement
 over standard RS codes. For more information about the
 encoding and decoding process of CRS codes, we refer the
 reader to [17]. The encoding performance of CRS codes and
 Fig. 2: The encoding process of parity-check packets of CRS
 codes with k = 4, n = 6 and w = 3.
 MS-BASIC codes shows in Fig. 3. The results of Fig. 3 show
 that MS-BASIC codes outperform CRS codes in encoding
 performance for file size of both 78.4MB and 440MB. The
 encoding time of CRS is roughly two times of the encoding
 time of MS-BASIC codes for all the evaluated parameters and
 files.
 (12, 6) (16, 8) (20, 10)0
 20
 40
 60
 80
 Parameters (n, k)
 En
 co
 din
 g t
 im
 e
 CRS, 78.4MB
 MS?BASIC, 78.4MB
 CRS, 440MB
 MS?BASIC, 440MB
 Fig. 3: The encoding time of MS-BASIC codes and CRS
 codes for data file size 78.4MB and 440MB with different
 parameters. The encoding time of CRS codes is roughly two
 times of the encoding time of MS-BASIC codes.
 37
B. Repairing Time
 When there is a node fails, MS-BASIC codes only need
 to download the amount of k+12k M data to repair the failure
 node using some addition and shift operations. For CRS codes,
 the new node first download M data to reconstruct the stored
 data file and then re-encode the lost packets. The results of
 repairing performance of CRS codes and MS-BASIC codes
 show in Fig. 4.
 (12, 6) (16, 8) (20, 10)0
 20
 40
 60
 80
 100
 120
 Parameters (n, k)
 Re
 pa
 irin
 g t
 im
 e
 CRS codes, 78.4MB
 MS?BASIC, 78.4MB
 CRS codes, 440MB
 MS?BASIC, 440MB
 Fig. 4: The repairing time of MS-BASIC codes and CRS
 codes for data file size 78.4MB and 440MB with different
 parameters. The repairing time of CRS codes is greatly larger
 than that of MS-BASIC codes for all the tested parameters.
 The performance repairing of CRS codes is worse than that
 of MS-BASIC codes, as expected. The repairing time of (10,
 20) CRS codes is about 20 times of that of MS-BASIC codes
 for file size 440MB.
 C. Decoding Time
 (12, 6) (16, 8) (20, 10)0
 20
 40
 60
 80
 100
 120
 Parameters (n, k)
 De
 co
 din
 g t
 im
 e
 CRS, 78.4MB
 MS?BASIC, 78.4MB
 CRS, 440MB
 MS?BASIC, 440MB
 Fig. 5: The decoding time of MS-BASIC codes and CRS
 codes for data file size 78.4MB and 440MB with different
 parameters. The decoding time of CRS codes is greatly larger
 than that of MS-BASIC codes for all the tested parameters.
 The decoding time of CRS codes and MS-BASIC codes
 shows in Fig. 5. The decoding time of CRS codes is also larger
 than that of MS-BASIC codes for all the evaluated parameters
 and files. The decoding time of (6, 12) CRS codes is a little
 bigger than 10 times of the decoding time of MS-BASIC codes
 (6, 12) for file size 440MB.
 From the evaluation, we see that MS-BASIC codes out-
 perform CRS codes in both coding time and repairing time.
 It makes MS-BASIC codes really competitive in practical
 distributed storage systems.
 VI. CONCLUSION
 In this paper, we give the construction of BASIC codes
 at the minimum storage point. MS-BASIC codes need no
 coding with minimal I/O cost in the repairing process that is
 a repair-by-transfer code. With the performance evaluation of
 CRS codes and MS-BASIC codes, we show that MS-BASIC
 codes outperform CRS codes in both repairing cost and coding
 cost, which makes MS-BASIC codes are very attractive in the
 coding of distributed storage systems.
 REFERENCES
 [1] H. Hou, K. W. Shum, M. Chen, and H. Li, ÒBASIC regenerating code:
 Binary addition and shift for exact repair,Ó in Proc. IEEE Int. Symp. Inf.
 Theory, Istanbul, July 2013, pp. 1621Ð1625.
 [2] S. Ghemawat, H. Gobioff, and S. Leung, ÒThe Google file system,Ó in
 ACM SIGOPS Operating Systems Review, vol. 37, no. 5. ACM, 2003,
 pp. 29Ð43.
 [3] N. Ellison, C. Steinfield, and C. Lampe, ÒThe benefits of facebook
 friends: social capital and college students use of online social network
 sites,Ó Journal of Computer-Mediated Communication, vol. 12, no. 4,
 pp. 1143Ð1168, 2007.
 [4] A. Dimakis, P. Godfrey, Y. Wu, M. Wainwright, and K. Ramchandran,
 ÒNetwork coding for distributed storage systems,Ó IEEE Trans. Inf.
 Theory, vol. 56, no. 9, pp. 4539Ð4551, September 2010.
 [5] V. R. Cadambe, S. A. Jafar, and H. Maleki, ÒMinimum repair bandwidth
 for exact regeneration in distributed storage,Ó in IEEE Wireless Network
 Coding Conference (WiNC). IEEE, 2010, pp. 1Ð6.
 [6] B. Gasto«n, J. Pujol, and M. Villanueva, ÒQuasi-cyclic minimum storage
 regenerating codes for distributed data compression,Ó in IEEE Data
 Compression Conference (DCC). IEEE, 2011, pp. 33Ð42.
 [7] K. V. Rashmi, N. B. Shah, and P. V. Kumar, ÒOptimal exact-regenerating
 codes for distributed storage at the MSR and MBR points via a product-
 matrix construction,Ó IEEE Trans. Inf. Theory, vol. 57, no. 8, pp. 5227Ð
 5239, 2011.
 [8] A. Duminuco and E. Biersack, ÒA practical study of regenerating codes
 for peer-to-peer backup systems,Ó in 29th International Conference on
 Distributed Computing Systems ICDCSÕ09. IEEE, 2009, pp. 376Ð384.
 [9] F. Oggier and A. Datta, ÒSelf-repairing codes for distributed storagea
 projective geometric construction,Ó in IEEE Information Theory Work-
 shop (ITW). IEEE, 2011, pp. 30Ð34.
 [10] H. Hou, H. Li, and K. W. Shum, ÒGeneral self-repairing codes for dis-
 tributed storage systems,Ó in Proc. IEEE Int. Conf. on Communications,
 Budapest, June 2013, pp. 1743Ð1747.
 [11] S. Pawar, N. Noorshams, E. R. S., and K. Ramchandran, ÒDress codes
 for the storage cloud: Simple randomized constructions,Ó in Proc. IEEE
 Int. Symp. Inf. Theory, Saint-Petersburg, July 2011, pp. 2338Ð2342.
 [12] S. Jiekak, A. Kermarrec, and N. Le Scouarnec, ÒRegenerating codes: A
 system perspective,Ó arXiv preprint arXiv:1204.5028v2, 2012.
 [13] C. W. Sung and X. Gong, ÒA zigzag-decodable code with the mds
 property for distributed storage systems,Ó in Proc. IEEE Int. Symp. Inf.
 Theory, Istanbul, July 2013, pp. 341Ð345.
 [14] T. W. Hungerford, Algebra, 2nd ed. New York: Springer-Verlag, 1974.
 [15] R. A. Horn and C. R. Johnson, Matrix analysis. Cambrdige: Cambridge
 University Press, 1985.
 [16] J. Bloemer, M. Kalfane, R. Karp, M. Karpinski, M. Luby, and D. Zuck-
 erman, ÒAn XOR-based erasure-resilient coding scheme,Ó 1995.
 [17] J. S. Plank, ÒOptimizing Cauchy Reed-Solomon codes for fault-tolerant
 storage applications,Ó University of Tennessee, Tech. Rep. CS-05-569,
 2005.
 38
