AMD based Service Agent Collaboration and Specification
 Liwei Zheng
 Computer School
 Beijing Information Science&Technology University
 Beijing, China
 Email: zlw@bistu.edu.cn
 Abstract— With the emergence of Big Data in Internet,
 composing existing web services for satisfying new require-
 ments,such as data quality enhancing, effective data choos-
 ing,knowledge discovering etc, has gained daily expanding at-
 tentions and interests. Many efforts have been pursued for sup-
 porting the essential activities in service composition. However,
 the existing techniques only focus on passive services which
 are waiting there for being discovered and invoked. We argue
 that it might be more attractive when Web services become
 active entities (Service Agent) distributed in Internet which
 can recognize the newly emergent requirements and compete
 with others for realize (part of) the requirements. Retreating or
 refinement of Big data will hardly be accomplished by one or
 two data handling center, Service Agent collaboration would be
 a competitive method for the big data handling problem. Mostly
 more than one service agents have to collaborate to satisfy
 requirements in current internet environment especially with
 social networks. That could be called as the requirement driven
 agent collaboration. Research on such collaboration might be
 useful for the previous problem. We have given a preliminary
 model for the requirement driven agent collaboration based on
 a function ontology and the automated mechanism design in
 the earlier work.This paper extended the Function Ontology,
 and enhanced the AMD model. That makes the interactions
 in MAS generated by agent collaboration can be described.A
 negotiation frame for the evaluation and choice of collaboration
 solutions is also given in this paper. It helps the requester
 evaluate the possible MAS systems, and helps the service agents
 make decisions to choose a good enough solution by negotiation.
 According to the dependencies provided in Function Ontology,
 a specification is given to describe the execution process of
 the chosen MAS. And also a method is given to translate the
 specification to BPEL which is more standard, acceptable, and
 easier to understood.
 Keywords-Multi-Agent;Collaboration; Mechanism design
 I. INTRODUCTION
 A multi-agent system (MAS) is a loosely coupled network
 of problem-solver entities that work together to find answers
 to problems that are beyond the individual capabilities or
 knowledge of each entity [5]. Currently, agent-based systems
 technology is particular attractive for creating software that
 operates in environments that are distributed and open,
 such as the internet. At present, there are already many
 MASs, e.g. those registered in the agentcities [2]. However,
 there are mainly two kinds of computing mechanisms for
 these systems. The first one is centralized and centered by
 a system manager or a coordinator, e.g. the description
 database with the kernels in MACE [8]. In which, the
 manager allocates tasks and chooses strategies and the other
 agents behave according to the commands issued by the
 manager. FIPA [3] gives a standard for this kind of MASs.
 The second is decentralized and includes those multi-agent
 systems based on game theory. In such systems, agents form
 coalitions, make solutions by negotiation, and work under
 some manually given rules which are designed for particular
 purposes [7] [12].
 Currently, service-oriented architecture, connecting Web
 services, has been paid lots of attentions for distributed
 computing and communication on loose coupling and het-
 erogeneous platforms [14]. In this architecture, Service
 Agency is responsible for managing and discovering ser-
 vices; Obviously, it is a centralized model. When considering
 the Web services as the Service Agents, this mechanism
 of service-oriented computing may appeal a decentralized
 computing mechanism for MASs. This computing mech-
 anism can be demonstrated by the following scenario.
 A requestor publishes a task request onto the Web. The
 available Service Agents on the Web detect the newly
 emergent requirements, recognize those (sub-)tasks which
 they can accomplish, and compete for being a member of
 the candidate agents for the request. After all the candidate
 Service Agents gather together, the technique of mechanism
 design is used to generate the protocols to make these service
 agents collaborating to fulfill the task request. We call this
 kind of computing mechanism the requirement driven agent
 collaboration [16] [17].
 Figure 1 demonstrates the scenario of the requirement
 driven agent collaboration in distributed and open Web en-
 vironment. In this figure, the larger ellipses are the requests
 submitted by requestors which are usually represented by
 some kind of task specification. The smaller circles are
 available service agents. For an ellipse, there are some
 circles around it. That means those service agents have rec-
 ognized that they are able to make contribution to the request
 satisfaction and are willing to compete with others for some
 of the sub-requests. In this sense, the requirement driven
 agent collaboration means the process of agent congregation
 for completing an emergent requirements. In this process,
 each request seems like a magnet which can make the service
 agents moving towards it. That is the reason we use the term
 2013 IEEE International Conference on High Performance Computing and Communications & 2013 IEEE International Conference
 on Embedded and Ubiquitous Computing
 978-0-7695-5088-6/13 $26.00 © 2013 IEEE
 DOI 10.1109/HPCC.and.EUC.2013.327
 2277978-0-7695-5088-6/13 $31.00 © 2013 IEE
of ‘magnet effect’ for capturing the relationship between the
 requirements and the service agents.
 Request
 Service Agent
 Figure 1. Magnet effect between requests and agents
 We have proposed a framework for the requirement driven
 agent collaboration [16]. It gives a computing mechanism for
 multi-agent systems which we believe will help to realize
 the vision for the next Web revolution. A Functional On-
 tology(FO) [15] was constructed for supporting the service
 agents to understand the specification of the request. This
 ontology provides the terminology for describing both the
 requested tasks and the service agents’ capability. So, with
 this ontology, service agents can understand the require-
 ments and decide if they need to be engaged for fulfilling the
 requirements. For making the service agents automatically
 collaborating, the model of Automated Mechanism Design
 (AMD) [13] was extended by introducing the task require-
 ments and the process of generating the outcomes from the
 task requirements.Figure 2 depicts the extended AMD.
 R
 Outcomes AM
 D
 M
 Appropriate
 Agent Group
 A request
 The Outcomes
 from the
 Requirement
 The
 Mechanisms
 Created by
 AMD
 Figure 2. Extended AMD
 With a mechanism, the candidate agents can choose
 functions and solutions to satisfy the request. When all the
 agents decide which function or functions they will do, a
 MAS would be established. For a given requirement, there
 might be many possible MASs which could be offered by
 the aggregated agents. Evaluating these possible systems
 effectively is necessary for the customer. In this paper, a
 kind of agent named requester does the customer’s job
 . The requester can evaluate single candidate agent and
 possible coalitions the agents may form according to the
 quality of service. Based on the evaluation, a negotiation
 framework is given. In this framework, the requester and
 all the service agents will negotiate to choose a good
 enough coalition and collaboration solution which means a
 executable MAS system. The chosen solution would satisfy
 the requirement both in function and quality and satisfy
 the service agents in their payoffs. When the coalition and
 the collaboration solution is decided, a specification which
 describes the agent collaboration process should be given.
 In this paper we extend the function ontology. Dependencies
 are defined for behaviors and functions to describe the
 possible relations between behaviors or functions. Based on
 the extended function ontology, we give a specification for
 the MAS established by the agents. And the specification
 can be translated to BPEL [4]which is a process describing
 language widely used in describing the composition of web
 services.
 This paper is organized as follows. Section 2 gives the
 extended Functional Ontology. Section 3 gives the extended
 definitions in AMD model and introduces the agent col-
 laboration model based on AMD briey which has been
 described in detail in our earlier work [15]. Section 4
 gives the evaluation method for service agents and agent
 coalitions. The negotiation frame between agents is also
 discussed in this section. Section 5 gives the specification
 of the chosen MAS system and the translation to BPEL
 language. Section 6 gives the conclusions and some future
 research work.
 II. EXTENDED FUNCTION ONTOLOGY
 For enabling the requirements driven agent collaboration,
 agent have to understand the specification of requirement.
 A Functional Ontology is constructed for this purpose. This
 ontology gives the the same terminology for describing the
 capability of agents and requests.
 The Functional Ontology is represented in a hierarchy of
 controllable resources together with the effects on them[6].
 In the Functional Ontology, each individual resource has
 attributes. These attributes are dived into two groups: the
 static attributes, i.e. their values are fixed once the attributes
 are instantiated, and the dynamic attributes, i.e. their values
 are changeable along different situations. We call the static
 attributes with their values the “ information” of the resource
 and call the dynamic attributes with their values the “ states”
 of the resource. Any set of state changes of a resource is
 called an effect on this resource. In the following paragraphs,
 we give the definitions of some important basic concepts
 and the extending in the functional ontology and discuss the
 characteristics of them.
 Resource. Anything that can be identified and can be op-
 erated by software agents is a kind of resource at a particular
 domain. e.g., information (value, date, etc.), physical entities
 (hardware, people, etc.), software systems and so on. All of
 these resources are defined by a set of attributes, each of
 which features some aspect of the resources. The attributes
 of a resource are classified into static ones and dynamic
 2278
ones. A static attribute is irrespective of time and keeps its
 value all the lifecycle. A dynamic attribute might change its
 value when external conditions change.
 Definition 2.1: (Resource)Resource is described as a 6-
 tuple
 Res :=< SAttr, DAttr, SARan, DARan, V alF uncofSAttr,
 V alF uncofDAttr >
 in which,
 • SAttr = {a1, · · · , an}, n ? N is a finite set of static
 attributes of the resource;
 • DAttr = {da1, · · · , dan}, n ? N is a finite set of
 dynamic attributes of the resource;
 • SARan = {v1, · · · , vm}, m ? Nis a finite set of static
 attribute values of the resource;
 • DARan = {dv1, · · · , dvm}, m ? Nis a finite set of
 dynamic attribute values of the resource;
 • V alF uncofSAttr : SAttr ? SARan is a value
 function of static attributes; and
 • V alF uncofDattr : DAttr ? P(DARan) is a
 value function of dynamic attributes. P(DARan) is the
 power set of DARan.
 For the convenience of narration, several symbols about
 the resource are listed here.
 • @ is a general separator, means “ of”;
 • sa@res means a static attribute sa of resource res;
 • da@res means a dynamic attribute da of resource res;
 State. The state of a resource characterizes the value of
 the dynamic attribute. As the situations change, the values
 of dynamic attributes may change too, which result in the
 transitions of the resource states. So we also called dynamic
 attributes as state attributes.
 Definition 2.2: (State) Let res be a resource
 and da1, ..., dan be n dynamic attributes of it. A
 state of res is st@res = (val1, ..., valn),vali =
 V alF uncofDAttr(dai), i = 1, ..., n.
 Behavior. The behaviors can be defined as the state
 transitions of the resources. As state transitions could be
 viewed as the basic effects imposed on resources, that
 means we model behavior as possible primitive operation
 on resource. In this sense, we give the following definition.
 Definition 2.3: (Behavior) A behavior is defined as a
 triple:Beh :=< res, s0, s1 >, res is the resource operated
 by Beh. s0 is the state of res before the operation. s1 is
 the state of res after the operation.
 Definition 2.4: (Sequential Behaviors) If we have
 beh1 =< res, s0, s1 >,beh2 =< res, s1, s2 >, we say beh1
 and beh2 are sequential. beh1 is the direct precedent of
 beh2. beh2 is a successor of beh1
 Function. The functions are conceptual classes of con-
 crete functional models. Generally a function description
 includes two parts: a capability description and some con-
 straints. The capability of a function can be represented by
 a set of behaviors. Constraints are limitations of functions.
 Most constraints are domain-related. Generally they can be
 represented as some logic expressions of the resource state.
 So we give the following definition.
 Definition 2.5: (Function) Function is described as a 7-
 tuple
 F unc :=< Beh, Res, Cond, CondF uncofBeh, P rop,
 P ropF uncofBeh, Dependency >
 in which,
 • Res is the operable resources set;
 • Beh is a set of all behaviors of the function;
 • Cond is a logic expression set of resource state;
 • CondF uncofBeh : Beh ? P(Cond) is a condition
 function which gives the execution conditions for each
 behavior;
 • P rop is a payoff distribution proportion set of the
 behaviors and
 ∑
 pi?Prop pi = 1;
 • P ropF uncofBeh : Beh ? P rop is the proportion
 function of behaviors.
 • Dependency :=< DirecBehDepen, CondBehDepen >
 in which,
 – DirecBehDepen is a relation set, for any relation
 (behi, behj) ? Beh?Beh,
 (behi, behj) ? DirecBehDepen iff behj is a
 successor of behi and CondF uncofBeh(behj) =
 ?. We call such relations direct behavior depen-
 dency;
 – CondBehDepen is a relation set,for any relation
 (behi, behj) ? Beh?Beh,
 (behi, behj) ? CondBehDepen iff behj is a
 successor of behi and CondF uncofBeh(behj) =
 ?.We call such relations conditional behavior de-
 pendency.
 Function Decomposition Mode. A function decomposi-
 tion mode is a description which describes how to decom-
 pose a function into sub-functions.
 Definition 2.6: (Function Decomposition Mode) Let
 func be a function. A function decomposition mode for
 func is a 7-tuple
 F uncDecMod(func) :=< SubF uncs, Cond, CondF uncofSubF uncs
 P rop, P ropF uncofSubF uncs, Dependency >
 , in which
 • SubF uncs = func1, ..., funcn is a set of
 functions,funci(1 ≤ i ≤ n) is a sub-function of func;
 • Cond is a logic expression set of resource state, and
 the resources are in the resource set of func.
 • CondF uncofSubF uncs : SubF uncs? P(cond) is a
 condition function which gives the execution conditions
 for each subfunction of func.
 2279
• P rop is a payoff distribution proportion set of the
 subfunctions, and
 ∑
 pi?Prop pi = 1;
 • P ropF uncofSubF uncs : SubF uncs ? P rop is a
 proportion function of the sub-functions.
 • Dependency :=< DirecF uncDepen, CondF uncDepen >
 in which,
 – DirecF uncDepen is a relation set, for any rela-
 tion (funci, funcj) ? SubF uncs? SubF uncs,
 (funci, funcj) ? DirecF uncDepen iff
 funcj is the direct successor of funci
 in the subfunction execution sequence and
 CondF uncofBeh(funcj) = ?. We call such
 relations direct behavior dependency;
 – CondF uncDepen is a relation set,for any relation
 (funci, funcj) ? SubF uncs? SubF uncs,
 (funci, funcj) ? CondF uncDepen iff
 funcj is the direct successor of funci
 in the subfunction execution sequence and
 CondF uncofBeh(funcj) = ?. We call such
 relations direct behavior dependency.
 With the same terminology, we represent an agent with a
 four-part-structure, i.e. a set of behaviors, a set of resources
 which it operates on, a set of state transitions that it enables,
 and a function from the behavior set to the transition set.
 Then the process for an agent to recognize a given request
 includes the following steps:
 1) Find its operatable resources in the request’s resource
 vector. If there is no matched resource, the request is not
 suitable for it, else record all the matched resources.
 2) Get the beginning state and the ending state of each
 matched resource from the requirement.
 3) Computing state transition pathes from the starting state
 to its corresponding end state for each matched resource
 according to FO.
 4) Check whether it has a behavior which can enable one
 of the effective state transitions.
 5) If it has no matched behaviors, the request is not
 suitable for it, else it becomes one of the candidates of the
 request.
 Any appropriate agent group has a time limitation for
 waiting its candidate agents. This time limit is different
 for each request which is decided by the request provider
 base on his/her experiences. After the waiting time, a local
 environment composed of a request and its candidate agents
 will be constructed. This environment is called a requirement
 domain. The candidate agent set in a requirement domain is
 also called an appropriate agent group of the requirement.
 These agents in the appropriate agent group will collaborate
 to complete the request.
 III. AGENT COLLABORATION BASED ON AMD
 The agent collaboration in a requirement domain can be
 finished with the helping of AMD. In our earlier work,
 the collaboration process includes two steps.The first is the
 process of automated mechanism design. That would give
 optimal outcomes for different agent groups. The second
 step is the agent negotiation process for given outcomes.
 That would produce effective agent behavior sequence for a
 given outcome. In this paper, we give a new AMD model,
 which can provide collaboration solutions directly for the
 appropriate agents. The model of automated mechanism
 design includes the preconditions for AMD, the mechanism
 definitions, and the constraints definitions.
 AMD is an approach, where the mechanism is computa-
 tionally created for the specific problem instance at hand. In
 Automated Mechanism Design, we need:
 • a finite set of outcomes O;
 • a finite set of N agents;
 • for each agent i,
 – a finite set of types ?i,
 – a probability distribution ?i over ?i(in the case of
 correlated types, there is a single joint distribution
 ? over ?1 ? . . .??N ),
 – a untility function ui : ?i ?O ? R;
 • an objective function whose expectation the designer
 wishes to maximize.
 Here, let N Agents be N Service Agents. In order to
 apply AMD in our work to fulfill the goal of Service Agents
 aggregation, we should define the outcome set and each
 Service Agents’ type set. In this paper, they are defined
 below.
 Definition 3.1: (Type Set)The type set of a Service Agent
 is defined as a vector set whose elements are all the permuta-
 tions of nodes that, written in the form of vector, the Service
 Agent could match on the Requirement Decomposition Tree.
 Definition 3.2: (Outcome Set)The outcome
 set of a Top-Level function(F 11 ,F 12 ,· · ·,F 1n1 ) is
 defined as a vector set whose elements are vector
 (F DM1i1 , F DM2i2 , . . . , F DM sis), s ? N satisfying the
 following two conditions:
 • Every heft of the vector is FDM node of Requirement
 Decomposition Tree, and the order is from the top to
 bottom of the tree.
 • Every Vector denotes one unique path to accomplish a
 top-level function
 With above definitions, Automated Mechanism Design
 is applied so that the Service Agent would participate the
 aggregation without manipulation.
 In our AMD mode, mechanisms are deterministic. A
 deterministic mechanism without payments consists of an
 outcome selection function o : ?1? ...??N ? O. A deter-
 ministic mechanism with payments consists of an outcome
 selection function o : ?1? ...??N ? O and for each agent
 i, a payment selection function pii : ?1 ? ... ? ?N ? R.
 The payment is for the request provider.
 Two types of constraints are used in our AMD pro-
 cess, IR(individual rationality constraints) and IC(incentive
 2280
compatibility constraints). IR constraints ensure every agent
 participator would gain its lower limit of payment at least.
 IC constraints is to ensure the agents will never misreport
 their type. For example the definition of an ex interim IR
 constraint is: for any agent i, and any type ?i ? ?i, we have
 E(?1,...,?i?1,?i+1,...,?N)|?i[ui(?i, o(?1, ..., ?N ))?
 pii(?1, ..., ?N )? ?] ≥ 0
 in which ? ? R is the lower limit of agent i’s payment,
 pii : ?1? ...??N ? R is a payment selection function for
 the requirement provider.
 AMD finds all the mechanisms which can satisfy all the
 constraints. The mechanisms provide all the possible func-
 tion choices for the candidate agents to satisfy the request.
 And it also provide the efficient collaboration solution by
 the outcome for different agent type set. Therefore, with a
 mechanism, the candidate agents can choose functions and
 solutions to satisfy the request. When all the agents decide
 which function or functions they will do in the solutions, a
 MAS would be established.
 IV. MAS EVALUATION AND THE NEGOTIATION
 FRAMEWORK
 A MAS system is an agent coalition with a certain collab-
 oration solution. According to the Function Ontology and the
 mechanisms provided by AMD, agents choose functions in
 different function decomposition mode. A different choice
 they made means a different MAS system. And for there
 may be many agents with a same type, there might be many
 possible agent coalitions for a given collaboration solution.
 Therefore there are many possible MAS systems after the
 process of AMD. All the service agents in the requirement
 domain must negotiate to choose a final coalition and
 the collaboration solution. In our papers earlier, a group
 decision making model– barycenter model was given. Based
 on the model, agents negotiate to choose a final solution.
 In this paper, we prefer to let the requester do the work of
 evaluation and negotiating with the service agents to choose
 the most appropriate MAS system.
 Maximellien gave a QoS Ontology [11] for web services,
 which includes most of the familiar quality evaluation items,
 such as responding time,throughput,latency, LoadBalancing,
 and etc. This Ontology can also be used to evaluate service
 agent. By referring the QoS Ontology, the requester can eval-
 uate the candidate service agent in each quality item. In this
 sense, we give a quality evaluation function for an arbitrary
 service agent agenti when it was doing a function F unci.
 Assume the evaluation is carrying on in n quality item, and
 a unique evaluation interval [0, MAXE], MAXE ? R is
 used, the function is as follows.
 Qua(Agenti, F unci) = 1
 n
 n∑
 i=1
 ?i?i
 in which, ?i ? [0, MAXE] is the evaluation value for the
 ith quality item, ?i is a preference value for the ith quality
 item of the requester.
 Based on the above definition, we give the evaluation
 of a MAS system. Suppose the request needs N functions,
 F unc1, ..., F uncN , and solutioni is one of the possi-
 ble collaboration solutions. Agenti will execute F unci in
 solutioni. Assume the preference to F unci of the requester
 is pi, then the evaluation function of solutioni is
 Squa(solutioni) = 1N
 N∑
 i=1
 piQua(Agenti, F unci)
 According to the evaluation value, the requester will give
 a payoff value to the given solution. Commonly, higher
 evaluation value means higher solution payoff. Because
 requesters would pay more for a more qualifiable solution.
 Hence, the payoff function of a solution must have a positive
 correlation with the solution evaluation function. We give a
 solution payoff function which is positive correlated with
 the evaluation function as follows.
 P ayoff(solutionj) = Squa(solutionj)MAXE MaxiP ay
 in which, MaxiPay is the maximum expected disbursement
 of the requester.
 With the solution payment given by requester, service
 agents can calculate the payoffs they can get according to the
 functions they will do in the solution. Some agents may get
 satisfiable payoffs and they will support the current solution.
 On the contrary, some other agents may be not satisfied by
 the payoff they got, and they will reject the solution. So
 agents must negotiate to find a solution which is satisfiable
 for all of them. However the solution which is good to all
 the service agents may be not good enough to the requester.
 A negotiation among the requester and all the service agents
 is required. We give a negotiation frame for this problem.
 The negotiation process can be represented by a small
 scenario. In the scenario, there are three agents. One re-
 quester and two service agents: Agenti and Agentj . The
 requirement is a implementation of three functions: F unc1,
 F unc2 ,F unc3. p1, p2, p3 are the preference value for the
 three functions of the requester. Minpayi is the minimum
 expected payoff of Agenti. Minpayj is the minimum
 expected payoff of Agentj . If an agent could not get a
 payment more than its minimum expected payoff, it will
 not participate the collaboration. The functions Agenti can
 do include F unc1 and F unc2. The functions Agentj can
 do include F unc2 and F unc3. The negotiation process is
 as follows.
 • Step1. Agenti proposes a most profitable solution of
 itself– solution1:let Agenti do F unc1 and F unc2 and
 let Agentj do F unc3.
 2281
• Step2. The requester evaluates solution1. Let k =
 MaxiPay
 MAXE , then the payoff of solution1 is
 P ayoff(solution1) = k3 (p1Qua(Agenti, F unc1)+
 p2Qua(Agenti, F unc2) + p3Qua(Agentj, F unc3))
 • Step3. Assume the agents distribute payoff according
 to the functions they do. Agenti will get
 payAi =
 k
 3 (p1Qua(Agenti, F unc1)+p2Qua(Agenti, F unc 2))
 Agentj will get
 payAj =
 k
 3 (p1Qua(Agentj, F unc3))
 If payAi ≥ Minpayi and payAj ≥ MinP ayj, then
 Agenti and Agentj will make an agreement, and
 solution1 will be chosen. If payAi < Minipayi, that
 means the most profitable solution of Agenti cannot
 reach its minimum expected payoff, Agenti will quit
 and the collaboration will fail. If payAj < Minipayj,
 that means the solution Agenti proposed is not good
 enough for Agentj , Agentj will reject solution1 and
 propose a new solution in the next step.
 • Step4. Agentj rejects solution1, and propose the most
 profitable solution for itself– solution2: let Agenti do
 F unc1, and let Agentj do F unc2 and F unc3.
 • Step5. Same with step2, the requester evaluate
 solution2. Agenti and Agentj will get new payAi
 and payAj . Similarly, if payAi ≥ Minpayi and
 payAj ≥ MinP ayj , then Agenti and Agentj will
 make an agreement, and solution2 will be chosen. If
 payAi < Minipayi, that means the solution Agentj
 proposed is not good enough for Agenti, Agenti will
 reject solution2 and propose a new solution. For the
 most profitable solution of Agenti,solution1, has been
 rejected by Agentj , Agenti will propose a suboptimum
 solution of itself. If payAj < Minipayj, that means
 the most profitable solution of Agentj cannot reach its
 minimum expected payoff, Agentj will quit and the
 collaboration will fail.
 • Step6. Repeat the above steps until the agreement is
 made or the collaboration fails.
 Figure 3 represents the negotiation process in the small
 scenario. In this figure, the three ellipses is the three
 agents, requester, Agenti and Agentj . The arrows represent
 the negotiation behaviors of the agents. These behaviors
 include: propose,evaluate,reject,and accept. The objects of
 the behaviors are solutions. The rectangles in the figure
 represent the solutions. solution1 is the most profitable
 solution of Agenti, and similarly solution2 is the most
 profitable solution of Agentj . solution3 is the suboptimum
 solution of Agenti which is not mentioned in the above
 steps. In figure 3,Agentj accepted solution3, that leads the
 Figure 3. Negotiation process in a small scenario
 final solution of the negotiation will be solution3, and it
 is represented by a nested rectangle. The label number in a
 circle represents the behavior sequence of the three agents.
 The candidate agent coalition and the final chosen solu-
 tion will make a executable MAS system. And this MAS
 system is generated by the agents themselves including the
 requester and all the service agents.
 V. SPECIFICATION OF THE MAS
 When the service agent coalition and the collaboration
 solution are chosen, a specification of the final MAS system
 must be available. Based on the dependencies between
 behaviors and functions, we can draw and describe the
 interaction process of the agents in a MAS and give a
 specification like figure 4 by following concepts and ex-
 pressions.
 • process{} is a block which includes a group of inter-
 actions of agents, it can also include sub-processes.
 • Block parallel{}includes paralleled interaction se-
 quences.
 • Block sequence{}includes a group of agent behaviors,
 any adjacent two behaviors have direct behavior depen-
 dency.
 • link{} is a block defined in parallel block, it describes
 the relationship between two behaviors which are in
 paralleled sequences.
 • The expression condition? A:B means when the condi-
 tion is true behavior A will be executed, otherwise B
 will be executed.
 This specification language is expressed in ABNF(the
 augmented BackusCNaur form) [1]which extended the
 Backus-Naur form. For the convenience of representation, in
 our expression the rules are all included in a pair of ”<>”
 as the form of rules in BNF. The ABNF expression of our
 specification language is as follows.
 • < process >= ”process{” ? (< parallel > / <
 sequence > / < process >)”}”
 • < parallel >= ”parallel{””link{” <
 linkstatement > ”}”2? < process > ”}”
 2282
Process{
      Parallel{
 Link{link1;}
                Sequence{
                 A1.b1;
                 A2.b1(source,link1);
                 }               
Sequence{
                 A3.b1;
                 A2.b2(target,link1);
                 cond?A3.b1:A3.b2;
 }                                          
Sequence{
                 A4.b1;
    Parallel{
  Sequence{A5.b1;}
  Sequence{A6.b1;}
 }
 }             
    }
 }
 Figure 4. A specification of MAS
 • < sequence >= ”sequence{”? < behaviors > /? <
 conditionstatement > ”}”
 • < linkname >= 1 ? V CHAR
 • < linkstatement >=< linkname > ”; ”
 • < behaviors >= 1 ?
 V CHAR[”(””source”/”targe””, ” < linkname >
 ”)”]
 • < conditionstatement >= ”cond””?” <
 behaviors > ” : ” < behaviors > ”; ”
 Some symbols used in our expression should be explained
 here. In ABNF, a rule may be defined by listing a sequence
 of rule names. That means a blank connects two rules. A rule
 may be defined by a list of alternative rules separated by a
 solidus (”/”). To indicate repetition of an element the form
 < a > ? < b >element is used. The optional < a > gives
 the minimum number of elements to be included with the
 default of 0. The optional < b > gives the maximum number
 of elements to be included with the default of infinity.[Rule]
 means the rule is optional. VCHAR is one of a core rules in
 ABNF which means visible (printing) characters. The core
 rules are defined in the ABNF standard.
 This specification describes all the possible collaboration
 relations in the generated MAS system. The sequence block
 includes the sequence of agent behaviors, e.g. A1.b1; in
 figure 4. A1.b1 is a behavior b1 which is owned by an agent
 A1. The symbol ”;” separates two sequential behaviors. The
 condition expression is used to describe the choice relation
 with conditions among agent behaviors. The parallel block
 includes paralleled behavior sequences. But two behaviors
 may be sequential even when one of them is in a paralleled
 sequence. The link block is used to describe this kind of
 relation between two behavior. The sequence relation is drew
 from the direct behavior dependency in Function Ontology,
 and the switch choice relation is drew from the conditional
 behavior dependency.
 Business Process Execution Language (BPEL) [4] is a
 business process modeling language that is executable. The
 origins of BPEL can be traced to WSFL and XLANG.It
 is serialized in XML and aims to enable programming in
 the large. Programming in the large generally refers to the
 high-level state transition interactions of a processBPEL
 refers to this concept as an Abstract Process. A BPEL
 Abstract Process represents a set of publicly observable be-
 haviors in a standardized fashion. It includes all the possible
 interaction structures,such as sequence, switch case, loop,
 and parallel. However an Abstract Process also includes
 information such as when to wait for messages, when to
 send messages, when to compensate for failed transactions,
 etc. These information are not needed for an MAS composed
 of autonomous and active agents. Agents do what they want
 to do. Our specification just tells customer or people what
 the agents would do and how they collaborate. That is the
 main deference between our specification and the traditional
 BPEL. Though BPEL is not suitable for MAS in some
 aspect, it is more standard and easier to be accepted and
 understood by customers. Therefore we give a algorithm
 to translate our specification to the Abstract Process of
 BEPL by the following algorithm. With the algorithm 5,
 Figure 5. Algorithm for translating MSL to BPEL
 the specification in figure 4 can be translated into a BPEL
 Abstract Process like figure ??.
 2283
For the differences between service agents and the clas-
 sical web service, the above BPEL abstract process cannot
 be used to deploy web services. But for a new request, if
 there exists MAS specification for it, the candidate service
 agents can using this specification or BPEL abstract pro-
 cess directly to instruct a MAS system. That means the
 mechanism design and the negotiation process are reused.
 Another useful point of the specification is in the MAS
 evaluation. In this paper, the coalition evaluation is based
 on the evaluation of single agent behavior, and the MAS
 structure or the collaboration relation is not used in evalua-
 tion. But two MAS system composed of same agent group
 with different structure may have different quality in treating
 a same request. However, the specification includes all the
 collaboration relations. It may bring big help for the future
 evaluation work which should consider the structure.
 VI. CONCLUSIONS
 Base on the requirement driven agent collaboration the-
 ory [18], [9], [10], this paper extended the Function On-
 tology, and modified the definition of agent type set and
 outcome set in AMD. The extending of Function Ontology
 makes the interactions in MAS generated by agent collab-
 oration can be described. The modification of AMD makes
 the generating of collaboration solution easier. A negotia-
 tion frame for the evaluation and choice of collaboration
 solutions is also given in this paper. It helps the requester
 evaluate the possible MAS systems, and helps the service
 agents make decisions to choose a good enough solution
 by negotiation. According to the dependencies provided
 in Function Ontology, a specification is given to describe
 the execution process of the generated MAS system by
 negotiation. And also a method is given to translate the
 specification to BPEL which is more standard, acceptable,
 and easier to understood. Based on the above work, the
 process of big data handling with service agent collaboration
 will be our central work in future.
 VII. ACKNOWLEDGMENTS
 This work was supported by the Beijing Municipal
 Education Commission Science and Technology Planning
 No.KM201311232013
 REFERENCES
 [1] Augmented bnf for syntax specifications: Abnf.
 http://tools.ietf.org/html/rfc4234.
 [2] http://www.agentcities.org/.
 [3] http://www.fipa.org/.
 [4] Ws-bpel 2.0 specification oasisstandard. http://docs.oasis-
 open.org/wsbpel/2.0/wsbpel-v2.0.pdf.
 [5] L. V. Durfee, E.H. and D. Corkill. Trends in cooperative
 distributed problem solving. In IEEE Transactions on Knowl-
 edge and Data Engineering, volume 1, pages 63-83, 1989.
 [6] L. Hou and Z. Jin. Fect: A modelling framwork for atuomat-
 ically composing web services. In WAIM 2005 Conference
 Proceedings,LNCS 3793, pages 320-332, 2005.
 [7] M. Klusch and O. Shehory. Coalition formation among
 rational information agents. In LNAI No. 1038, Agents
 Breaking Away. Springer-Verlag, pages 204-217, 1996.
 [8] C. B. L. Gasser and N. Hermann. Mace: A exible testbed
 for distributed AI research. Distributed Artif icial Intelligence,
 pages 119-152, 1987.
 [9] J. T. Liwei Zheng and Z. Jin. An agent based framework for
 internetware computing. International Journal of Software
 and Informatics, 4:401-418, 2011.
 [10] G. L. Lixing Li, Zhi Jin and L. Zheng. Modeling and
 analyzing the reliability and cost of service composition in
 the iot. In the proceedings of 19th International Conference
 on Web Services, pages 584-591, Oct 2012.
 [11] E. M. Maximilien and M. P. Singh. A framework and
 ontology for dynamic web services selection. IEEE Internet
 Computing, 8(5):84-93, Sept. 2004.
 [12] S. K. Onn Shehory. Methods for task allocation via agent
 coalition formation. Artif icial Intelligence, 101:165-200,
 1998.
 [13] T. Sandholm. Automated mechanism design: A new ap-
 plication area for search algorithms. In Proceedings of
 the International Conference on Principles and Practice of
 Constraint Programming(CP), 2003.
 [14] A. T. An overview of standards and related technology in
 web services. Distribute and Parallel Databases, 12:135-162,
 2002.
 [15] L. Zheng and Z. Jin. Requirement driven agent collab-
 oration based on functional ontology and AMD. In 11th
 IEEE International Workshop on Future Trends of Distributed
 Computing Systems, pages 189-198. IEEE Computer Society.
 [16] L. Zheng and Z. Jin. Requirement driven service agent
 coalition formation and negotiation. In Proceedings of the
 9th International Conference for Young Computer Scientists,
 Nov 2008.
 [17] L. Zheng and Z. Jin. Aggregation of autonomous internet-
 ware entities. In the proceedings of The First Asia-Pacif ic
 Symposium on Internetware, Oct 2009.
 [18] L. Zheng and Z. Jin. Agent oriented internetware modelling.
 In the proceedings of The Second Asia-Pacif ic Symposium on
 Internetware, Nov 2010.
 2284
