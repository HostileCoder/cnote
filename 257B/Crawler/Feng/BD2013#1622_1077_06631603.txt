Modeling MongoDB with Relational Model
 Gansen Zhao1, Weichai Huang3, Shunlin Liang3, Yong Tang1,2
 1School of Computer Science, South China Normal University, Guangzhou, China 
2Guangzhou Key Lab on Cloud Security andAssessment, Guangzhou, China 
3School of Software, Sun Yat-sen University,  Guangzhou, China 
gzhao@scnu.edu.cn 
Abstract— Relational databases have been prevailing for the last 
two decades, with features of clear semantics and ease of use with 
SQL supported by the underlying theory, relational algebra.
 Relational databases provide good support for structural data 
management. However, recent development in IT brings forward 
big data, featuring extreme large volume and variety in data type 
and structures, and relational databases are difficult to handle 
such big data due to the strict constraints on data structure and 
data relations, and so on. On the other hand, NoSQL databases, 
including HBase, MongoDB, Cassandra, etc., are receiving their 
popularity for their capability in dealing with large amount of 
complex data in various structures. Currently there is no way to 
know the feasibility of the migration of traditional relational 
databases to NoSQL databases. The migration requires 
evaluating the feasibility of the migration and potential 
performance of the new systems. This paper investigates these 
issues by modelling one of the NoSQL database, MongoDB, with 
relational algebra. The modelling will allow the comparison of 
semantic expression powers between relational databases and 
MongoDB, analysing the feasibility of the migration of a 
relational database to MongoDB and its evaluation. The model is 
expected to facilitate the optimization of the new NoSQL 
database. 
Keywords—Relational Algebra, Relational Model, SQL, NoSQL, 
MongoDB  
I. INTRODUCTION
 Modern relational databases are established based on the 
relational model of data proposed by E.F. Codd[1]. Codd 
defined the relational algebra and relational calculus on the 
basis of the relational model, with the primary set operators 
including union, intersection, selection, projection, and join.  
Relational databases feature a simple and unified data 
model, with relations as the basic model to represent the world. 
All entities are abstracted as relations, and the association and 
connection between entities are abstracted as relations as well. 
All operations on the entities and their connections are 
performed on the corresponding relations.  
Relations are represented as tables and views in relational 
databases, with tables as solid/physical representation of 
relations and views as virtual representation of relations. 
Each row in a table represents an entity, and a table 
represents a set of the entities. Each column in table represents 
a property of the entities corresponding to each row. 
Structural Query Language (SQL)[2] is a language 
designed for the query and management of structural data. 
Typical operation of SQL including select, join, update, and 
insert, etc. The select operation specifies entities which 
properties are interested to the users. It allows the construction 
of a view which contains only specified properties and only 
satisfactory entities of query criteria. The join operation is to 
link two sets of entities together to construct a new set of 
entities. The update operation is to modify the specified 
properties of a set of entities that match the query criteria. The 
insert operation is to add a new entity into an existing set of 
entities with the same property format. 
SQL promotes the development and deployment of 
relational databases due to its ease of use. Most relational 
databases have the SQL support as an essential part of the 
databases. 
Along with the higher demand in various fields, the original 
relational database system could not fully meet the needs of 
the society. It can be seen that the querying efficiency of the 
relational database system is quite low when it works with a
 huge volume of data. And it is obviously that the original 
relational database system does not have a good scalability, 
making the system difficult to deal with the rapidly increasing 
data. What’s more, some features, such as consistency, are not 
required for the current database system, and these 
unnecessary features are making the performance of the 
database system worse. Also, the high maintenance cost of the 
relational database system could not satisfy current enterprises. 
In recent years, a lot of new database systems integrated of 
various kinds of new technology have come out. These 
database systems had different models, like Key-value stores 
model, Table-oriented model, Document-oriented model, 
Graph-oriented model, etc. Most of these systems rely on 
models other than relational algebra. Generally, these database 
systems are called NoSQL database systems. 
Carlo Strozzi used the term NoSQL in 1998 to name his 
lightweight, open-source relational database that did not 
expose the standard SQL interface[3]. Eric Evans, 
a Rackspace employee, reintroduced the term NoSQL in early 
2009 when Johan Oskarsson of Last.fm wanted to organize an 
event to discuss open-source distributed databases.[4] The 
name attempted to label the emergence of a growing number 
of non-relational, distributed data stores that often did not 
attempt to provide atomicity, consistency, isolation and 
durability guarantees that are key attributes of classic 
relational database systems[5]. NoSQL database system has 
features of high performance, huge storage, high scalability 
and high availability.  
2013 Fourth International Conference on  Emerging Intelligent Data and Web Technologies
 978-0-7695-5044-2/13 $26.00 © 2013 IEEE
 DOI 10.1109/EIDWT.2013.25
 115
So far, there are more than two hundred published NoSQL 
productions, and some of them are well-known to us, such as 
BigTable, HBase, Cassandra, Redis, MongoDB, CouchDB. 
However, NoSQL systems are unfamiliar to most engineers 
and researchers; hence they think it difficult to migrate data to 
NoSQL systems from SQL system for the following reasons. 
Firstly, there are no existing methods for guiding the 
migration from SQL to NoSQL. Most migration work suffers 
from lack of experience and lack of specialist tools, not to 
mention a method for converting the SQL design into a 
NoSQL design. 
Secondly, there is no existing work for the evaluation of 
NoSQL system’s capability and performance, nor is there any 
work for the comparison of NoSQL systems with SQL 
systems. Users have extremely limited support for their 
decision choosing NoSQL systems. 
Thirdly, there is insufficient work on how to optimize a 
NoSQL system for performance and capability. System 
optimization is of immense importance for system deployment 
and system maintenance. Being able to optimize the system at 
design time and runtime is of considerable importance for the 
actual adoption of NoSQL systems. 
Hung-chih Yang, Ali Dasdan, Ruey-Lung Hsiao, and D. 
Stott Parker had improved the framework of MapReduce [6].
 They changed the MapReduce framework into Map-Reduce-
 Merge framework by adding the operation of Merge. Through 
this improvement, the framework provides MapReduce the 
capability of calculating relational algebra, which makes 
processing data in clusters possible. 
Tomasz Nykiel, Michalis Potamias, Chaitanya Mishra, 
George Kollios, and Nick Koudas had proposed MRShare 
framework to optimize the efficiency of MapReduce in 
2010[7]. They restructured the queries to create new batch 
tasks, which can reduce the query’s workloads, so that the 
efficiency of the query in clusters increases. 
Foto N. Afrati and Jeffrey D. Ullman have optimized the 
Join operation in the clusters [8]. They continued to optimize 
the multiway joins to make the querying more efficiently in 
2011[9].
 In this paper, we will take MongoDB as an example of 
NoSQL database to examine the feasibility of the migration 
from SQL to NoSQL, create a relational model for MongoDB 
and realize the querying operation by means of relational 
algebra. We will introduce MongoDB in the Section II. A
 brief summary of relevant concepts in relational algebra is 
presented in Section III. Section IV proposes the relational 
model based on MongoDB and gives an introduction to the 
model. Section V and VI discuss the achievement of common 
relational operations in MongoDB based on the model 
proposed in Section IV, including the situations of Single 
Sharding and Multiple Sharding. In Section VII is a summary 
of our work. 
II. INTRODUCTION OF MONGODB
 MongoDB is an open source document-oriented database 
designed for exceptionally high performance and developed in 
C++. Data is stored and queried in BSON in MongoDB, 
which is like JSON. It has dynamic schemas and is more 
flexible, which makes the integration of data easier and faster 
than traditional database productions.  
MongoDB can support the following features:  
 Ad hoc queries. 
MongoDB is a document-oriented database with no 
transactions and joins. So it is easier to write queries. 
 Indexing 
Any attributes can be indexed in the database. 
Secondary indices are also available. 
 Replication. 
MongoDB supports master-slave replication, which 
ensures redundancy, backup, and automatic failover. 
 Load balancing. 
MongoDB scales horizontally using sharding, which 
distributes a single logical database system across a cluster 
of machines. 
 File storage. 
Any files can be stored in MongoDB with the function 
GridFS. So MongoDB could be used as a file system. 
 Aggregation. 
MongoDB supports MapReduce, which enables users 
to obtain the result for which SQL GROUP BY clause is 
used. 
With the features above, MongoDB has many advantages. 
It is extremely fast. And it does not have data mapping, so it is 
easy to adapt quickly as requirements change. What’s more, 
MongoDB has high scalability, which makes it meet the 
demands of the current Web 2.0 applications. 
Considering that there are many differences between 
MongoDB and the original database system, how the data can 
be migrated from SQL to MongoDB? We propose the 
following solution: due to the fact that all the SQL operations 
are based on relational algebra, relational model represents the 
capability set of relational database system. If MongoDB has 
the same capability set of relational database system, or even 
has a greater capability set, we can come to a conclusion that 
data can be migrated from SQL to MongoDB. Let’s review 
the relational algebra first. 
III. RELATIONAL ALGEBRA
 Relational Algebra was proposed by E.F.Codd, the founder 
of relational database, as a basis for database query languages. 
Six primitive operators of relational algebra are set union, 
set difference, Cartesian product, selection, projection and 
rename. Other operators that are more complicate can be 
deduced by the six primitive operators. 
The intersection is not included in the six primitive 
operators, but it can be defined by the set difference.
 The intersection, the set union and the set difference are 
taken from set theory. For these operators, the two relations 
involved must be union-compatible, which means that they 
must meet the following requirements: 
 They have the same number of attributes. 
 They have the same scope of matching attributes from 
left to right. 
116
We will provide the operations of relational algebra precise 
definition in section V of this paper, combining with the 
specific concepts of MongoDB. 
IV. THE RELATIONAL MODEL OF MONGODB
  MongoDB is a document-oriented database system. A 
MongoDB system can have several instances of database. And 
a database instance could have many collections, which are 
comprised of different documents. Every document is 
composed by a series of interrelated keys. The collection does 
not have a predefined schema. To be specific, the keys in two 
documents can be quite different.
 With such data structure mentioned above, we use the 
relation’s conceptual model to demonstrate MongoDB. In the 
macro level, collections in MongoDB do not have similar 
fixed schema as relational model. In other words, the schema 
in a collection can be changed at any time. In such a situation, 
if T ?  T  > 0, we cannot determine the schema at time T
 even though knowing the schema at time T. However, in the 
micro level, the schema can be considered fixed. To be 
specific, the schema at time T is the same with the schema at 
time T , where lim? T  ? T   = 0 . That is, in such a 
moment, the schema of a collection could be decided.
 In the situation of lim? T  ?  T   = 0, the document’s 
model in MongoDB is the same with the relational model in 
relational database system. A collection is matching along 
with a table of a relational database. One document is like one 
tuple in a table, and the keys are similar to the fields in the 
table. There are no substantial differences between them.
 In conclusion, the relational model of MongoDB is: The 
collection of MongoDB is a table, and the table’s structure is 
changeable in the macro level but fixed in the micro level. In 
the moment of calculation, the table’s schema is composed by 
all keys in the document. All the keys in the document would 
be defined in the table’s every tuple. Every value in the table 
is corresponding to a value of a key. The value will be null if 
the document does not have a corresponding key. The model 
could be presented in the chart I.
 Chart I Mapping From Set to Table 
Additionally, the documents in the collection are not quite 
simple in many situations. Documents could be embedded or 
linked in other documents. For example, document “Book_A”
 is embedded into the document “Order_A”, we call the 
document “Book_A” Child Document, and the document 
“Order_A” Father Document. When this Father Document is 
mapping to the relational model, the document would be 
flattening. That is, keys in Child Document would be added a 
prefix before it becomes a field in the table. The prefix would 
be the name of the key which Child Document embedded in 
the Father Document, 
Moreover, we would face such a situation: there is not only 
one Child Document in a Father Document, for example, 
document “Book_A” and document “Book_B” are embedded 
in the document “Order_A”. The method mentioned above 
could not work, because the keys in each Child Document 
would be the same in the Father Document, which is not 
permitted in the relational table.
 Another viable solution is using the prefix which is 
consistent of the previous prefix and the id of the Child 
Document. With this solution, the problem can be solved 
easily. So the new key of a Child Document would be in the 
following format: [superkey]_[_id].[childkey]. Following is 
an example of the flattening.
 117
Chart II Flattening Mapping 
It should be noticed that because the document does not 
have a predefined schema, the mapped table would be sparse. 
When a collection is mapping to a table in the relational 
model, the table would be extremely large, with many empty 
values. That is the reason why all the collection’s keys would 
not map into the table. Specially, when the values in Child 
Documents do not participate in the calculation, the flattening 
is unnecessary; the Child Document can be shown as a DBRef.
 V. RELATIONAL ALGEBRA IN MONGODB
 As discussed previously, there are six primitive operators in 
relational algebra, and other operations can be deduced 
through these primitive operators. According to the relational 
model proposed above, we could define the six basic operators 
of relational algebra in MongoDB’s collection. 
A. Union Set 
Assuming that two operands are union-compatible, given 
two collections C and T in MongoDB, the definition of the 
union set is: 
C ? T = {x|x ? C ?  x ? T}, 
where C and T are union-compatible 
B. Different Set 
It is similar with union set. Given two collections C and T, 
the definition of the different set is: 
C ? T = {x|x ? C ?  x ? T},
 where C and T are union-compatible 
C. Selection 
A selection is a unary operation that extracts certain 
documents ?  contending the given condition p  from a 
collection. 
?(C) = {x|p(x)  ?  x ? C}
 where p is the query condition, for example age > 18. 
D. Cartesian product 
The definition of the Cartesian product in relational algebra 
is different from that in set theory. Tuples are considered to be 
'shallow' for the purposes of the operation. That is, the 
Cartesian product of an n-tuple by an m-tuple has the 2-tuple 
"flattened" into an (n + m)-tuple. In set theory, the Cartesian 
product is a set of 2-tuple. The definition is: 
R ? S = {r ? s|r ? R ? s ? S},
 Supposed that R has n tuples and S has m tuples, the result 
of R ? S has m ? n tuples. 
E. Projection 
Projection is to acquire certain keys and its values in the 
collection according to the given attribute set, and the result of 
the projection is a new collection. 
pi,,…,(C) = {(k, k, … , k)|kC. k ? i = 1,2, … , m}
  is one key in the collection C. 
Note that because two identical documents cannot be in one 
collection, although duplicate records would be appeared in 
the procedure of project operation, the final outcome of 
projection would be distinct. 
F. Rename 
During the operation, every key has its own name in each 
collection, and we can obtain its value through its name. But 
in the query of more than one collection, same key names 
would be defined in different collection, or when we want to 
rename certain keys in the result of the relational calculation, 
we need the rename operation to rename the keys and do not 
change any values. Following is its definition: 
?CF, T, F = (T. t ? C. c, … , T. t ? C. c)
 The set F which contains the new names of the keys in the 
collection T and C, is the result of the rename operation. The 
relation T and C have the same documents’ values but some 
different key names. To the keys whose names do not define 
in F, their names do not change after the operation. 
Aside from the six primitive operators, there are some 
notable operatiors that can be deduced from them: 
G. Intersection 
For the collection C and T,  
C ? T = {x|x ? C ? x ? T}, 
where C and T are union-compatible
 As mentioned above, intersection can be defined by a
 different set. To the universal set C, C ? T and C ? T are 
complementary, so:
 C ? T = C ? (C ? T)
 H. Conditional Join 
Conditional Join is to join more than one collection that 
satisfies a specific condition that the result of the conditional 
join is a subset of Cartesian product. The definition is: 
  = ( ? ), where p is the condition 
I. Natural Join 
ic
 118
Natural join is a peculiar condition of conditional join. It is 
demanded that the two documents in collection C and T could 
not be joined unless the keys with the same names in both 
documents have the same value. It is defined by the symbol : 
C T = ?(C ? T)
 where 
? = (C. k = T. k)   (C. k = T. k)  …  (C. k
 = T. k)!, 
and k  represents the keys with the same name in both 
relations, i = 1, 2, … , m.
 J. Division 
Although division is not very common in the database 
query, it is a useful operator of relational algebra. Following is 
the definition of the division of collection C and T: 
Assuming that the collection C has keys x and y, T only has 
key y, toany value V
 "
 of the key y in S and the value of key x 
V# in C, if <V#, V" > is contained in C, then V# ? C/T. That is,
 C/T is the collection of V# that meet the requirement above.
 To the V# does not meet the requirement, it can be defined 
as: 
pi$(pi$() ? ) ? 
  So
 C/T = pi$() ? pi$(pi$() ? ) ? 
 To the situation that there are more keys in C and T, x 
represents the keys only exist in C and y represents the keys 
exist in both C and T. 
According to the implementations above, MongoDB can 
support all the six primitive operators of relational algebra. In
 the next section, we are going to testify the feasibility of the 
immigration from SQL to MongoDB. 
VI. OPERATION OF MONGODB
 After the demonstration above, we can model the data 
query capability of MongoDB, using the relational algebra. 
The implementation would be considered in two situations in 
MongoDB: single sharding and multiple sharding, to be 
specific, the two different extended patterns. 
A. Single Sharding 
Single sharding means that the whole MongoDB is 
deployed on only one computer, and it is the only node of the 
database. The execution of the MongoDB operations is 
straightforward as all the evaluation of the queries is 
performed on a single node. 
1)  Find 
Find is the querying command of MongoDB, equivalent to 
SELECT command in SQL. Following is its command 
example: 
db.clltn.find({p}, {k1:1, k2:1, …, km:1}) 
It means to get a collection constituted by documents in the 
collection “clltn” which satisfy the condition p, and 
documents in the new collection only have the key-value pairs 
whose key is contained in the set k . We can achieve this 
query by the following relational algebra: 
Find(C, p, {k, k, … , k%}) = pi&',*+,,…,% ()!
 In the query, C is the collection; p is the query condition 
and k is the key which need to be extracted. The result of the 
query is a collection of documents that consist of key-value 
pairs, and the key-values are using {k, k, … , k} as their 
keys. 
2)  Distinct 
Distinct is an aggregation command of MongoDB. It is 
used to query all the values of the given key. For the 
following command: 
db.cllctn.distinct(“k”)
 or
 db.runCommand({“distinct”:“cllctn”, “key”:“k” })
 we can get all the values of key “k” in the collection 
“cllctn”. And it can be defined by following relational algebra: 
Distinct(C, k) = ?pi(C)
 In the equation, ? is not a relational calculus. It is just a 
formatting for the query result. And it should be noticed that 
the result of the query would not have key-value pairs like “k 
= -”.
 3)  Group 
Group is another aggregation command of MongoDB, that 
is equal to GROUP BY command in SQL. To the following 
command: 
The command divides the documents in the collection into 
groups according to key “k”, and documents with same key 
“k”’s value would be merged by the function defined in 
“reduce”. The operation will return the result of reduce. 
Following is the relational algebra calculation of the 
operation Group(C, k, reduce): 
1. Distinct(C, k) = ?3&() = {"k": v, v, … , v%}
 2. For  v5, i = 1,2, … , m
 R5 = ?6=v5()
 3. Group(C, k, reduce) = 7 reduce(R*)%*+
 To support more complicate group queries, MongoDB 
defines more parameters for them. For example, the parameter 
“condition” only allows the documents that meet the 
requirement of “p” to be contained in the operation; the 
parameter “finalize” provide the function to process the result.  
For an instance, 
119
The command Group(C, k, reduce, p, finalize) has the 
following equivalent relational algebra calculation: 
1. ?() = T
 2. Distinct(T, k) = ?3&() = {"k": v, v, … , v%}
 3. For  v5, i = 1,2, … , m
 R5 = ?6=v5()
 4. Group(C, k, reduce, p, 9inalize) =
 9inalize(7 reduce(R*))%*+
 4)  “Join”
 In the relational database, Join is a widely used operation. 
By using Join, relational database increases its flexibility of 
querying and enlarges its scope of application. 
But to our disappointment, MongoDB could not support 
Join yet. However, we are going to use relational algebra to 
achieve the Join operation for MongoDB, to increase the 
efficiency of query and to make it support more complicate 
queries. 
Following is the definition: 
To the collection C and T,  
C T = ?(C ? T)? p is the condition for joining.
 Let’s consider a common scene: 
when using MongoDB, sometimes we need to query two 
collections to get the result we want, just like:  
 
It is doubtless that we need to conduct two querying to 
obtain the result, and it is in poor efficiency. With relational 
algebra, we can use a Join to achieve the result: 
3;<?@ABE<.65 HIEJBE< IEJBE<.5J=q179  Orders.custid=Customers._id;<?@ABE<M ?
 where Customers. 6*  means the keys of the collection 
Customers. (i = 1,2, … , n)
 B. Multiple sharding 
Load balancing is an essential feature of MongoDB. That is, 
MongoDB can increase or remove its nodes on its clusters on 
the basis of its requirements. When there is more than one 
node in the MongoDB, data in a collection would be split and 
distributed across multiple shards to accomplish the goal of 
load balancing. This operation is called sharding in MongoDB.  
Assuming that the collection C has n shards, we can define 
C = 7 CN+ . Following we will provide the realization of 
relational algebra in the multiple sharding pattern. 
1)  Find 
On the basis of the discussion above, we can conclude that:  
Find(C, p, {k, k, … , k%}) = pi&',*+,,…,% ()!,
 where C = 7 CN+ , 
pi65,5=1,2,…,A P()! = pi65,5=1,2,…,A QP UW 5X
 5=1
 YZ 
= W pi&',*+,,…,% (*)![
 +
 so,
 Find(C, p, {k, k, … , k%}) = W pi&',*+,,…,% (*)![
 +
 C is the shards of the collection C, restoring in different 
nodes. 
2)  Distinct 
The distinct operation is similar with Find operation. What 
we need to do is to find out all the values in each shard, to 
integrate the values and to delete the reduplicate ones. 
According to the discussion above, 
Distinct(C, k) = ?3&()
 When C = 7 CN+ , 
Distinct(C, k) = ? Q3& UW *[
 *+
 YZ 
= ? UW 3&(*)[
 *+
 Y
 In the equation, ? is not a relational calculus, it is just a 
format for the query result. Something should be noticed that 
the result of queries has no key-value pairs like “k = -”.
 3)  Group 
In the discussion about Group above, we mentioned two 
situations. In fact, the first situation could be contained in the 
second one. So we just consider the second situation here.  
To the collection with multiple sharding, C = 7 CN+ ?
 following is the relational algebra calculation of the operation
 Group(C, k, reduce, p, finalize): 
1. ?() = ?(7 *[*+ ) = 7 ?(*)[*+ = T
 2. Distinct(T, k) = ?3&() = {"k": v, v, … , v%}
 3. For  v5, i = 1,2, … , m
 120
R5 = ?6=v5()
 4. Group(C, k, reduce, p, 9inalize) =
 9inalize(7 reduce(R*))%*+
 4)   “Join”
 To the collection C and T,  
C T = ?(C ? T)? p is the condition for joining
 When  C = 7 CN+ , T = 7 T\\+ , 
  = UW *[
 *+
 Y (T) 
= W *  (T)![
 *+
  
= W ]*   QW ^%
 ^+
 Z`[
 *+
  
= W QW *  ^%
 ^+
 Z[
 *+
 VII. CONCLUSION
 Based on the relational model proposed above, MongoDB 
can support relational calculus just like relational database 
system. We are certain that they have the same capability set.
 Therefore, we can get to the conclusion that theoretically data 
can be migrated from SQL to MongoDB safely and easily. 
NoSQL databases have become a popular alternative to 
traditional SQL databases, especially in the scenario where 
extremely large scale of data needed to be managed. The 
adoption of NoSQL solutions is called for theoretical and 
technical supports on evaluation of the solutions, comparison 
with SQL solutions and optimization of NoSQL solutions. 
The contributions of this paper are as follows. Firstly, we 
identify the need for theories and methods to support users’ 
evaluation of NoSQL solutions, comparison of NoSQL
 solutions with RDBMS. Secondly, we model MongoDB with 
relational algebra, allowing the understanding and analysis of 
MongoDB independent of the actual implementation. Thirdly, 
we prove the migration’s feasibility of traditional SQL 
applications to MongoDB.
 The current research suggests that it is possible to provide 
mappings between MongoDB and RDBMS. To be specific, 
given a RDBMS instance with its relation design, it is possible 
to construct a MongoDB instance that provides the same data 
management and query features as the RDBMS instance does. 
This work is the first attempt to investigate and understand 
NoSQL database formally, focusing on the mathematical 
modeling of MongoDB. For the comparison of MongoDB and 
RDBMS, the mathematic model of MongoDB is constructed 
with relational algebra, which is also the primary model of 
RDBMS.  
Further work includes the improvement of the current 
model as well as the investigation of automatic transformation 
of RDBMS designs into MongoDB designs. The optimization 
of MongoDB design is also of interest to us. 
VIII. ACKNOWLEDGEMENT
 Research supported in part by the Guangzhou Research 
Infrastructure Development Fund (No. 2012224-12), the 
Guangdong Nature Science Fund (No. S2012030006242), the 
Guangdong-CAS Cooperation Fund (No. 2011A090100003), 
the Guang-dong Emerging Industry Key Technology R&D 
Fund (No. 2011A010801007), the Guangzhou Zhujiang 
Science and Technology Future Fellow Fund (No. 
2011J2200089), and the MOE-China Mobile Research Fund 
(No. MCM20121051).
 REFERENCES
 [1] E. F. Codd. 1970. A relational model of data for large shared data 
banks. Commun. ACM 13, 6 (June 1970), 377-387. 
DOI=10.1145/362384.362685 
http://doi.acm.org/10.1145/362384.362685
 [2] ISO/IEC 9075-1:2008: Information technology – Database languages –
 SQL – Part 1: Framework (SQL/Framework)
 [3] Lith, Adam; Jakob Mattson. Investigating storage solutions for large 
data: A comparison of well performing and scalable data storage 
solutions for real time extraction and batch insertion of data. Göteborg: 
Department of Computer Science and Engineering, Chalmers 
University of Technology: 15 [2011-05-12].  
[4] NOSQL 2009. Blog.sym-link.com. 2009-05-12 [2010-03-29]. 
[5]  Mike Chapple. "The ACID Model" 
[6] Hung-chih Yang, Ali Dasdan, Ruey-Lung Hsiao, and D. Stott Parker. 
2007. Map-reduce-merge: simplified relational data processing on 
large clusters. In Proceedings of the 2007 ACM SIGMOD 
international conference on Management of data (SIGMOD '07). 
ACM, New York, NY, USA, 1029-1040. 
DOI=10.1145/1247480.1247602 
http://doi.acm.org/10.1145/1247480.1247602
 [7] Tomasz Nykiel, Michalis Potamias, Chaitanya Mishra, George Kollios, 
and Nick Koudas. 2010. MRShare: sharing across multiple queries in 
MapReduce. Proc. VLDB Endow. 3, 1-2 (September 2010), 494-505. 
[8] Foto N. Afrati and Jeffrey D. Ullman. 2010. Optimizing joins in a map-
 reduce environment. InProceedings of the 13th International 
Conference on Extending Database Technology (EDBT '10), Ioana 
Manolescu, Stefano Spaccapietra, Jens Teubner, Masaru Kitsuregawa, 
Alain Leger, Felix Naumann, Anastasia Ailamaki, and Fatma Ozcan 
(Eds.). ACM, New York, NY, USA, 99-110. 
DOI=10.1145/1739041.1739056 
http://doi.acm.org/10.1145/1739041.1739056
 [9] Foto N. Afrati and Jeffrey D. Ullman. 2011. Optimizing Multiway
 Joins in a Map-Reduce Environment. IEEE Trans. on Knowl. and 
Data Eng. 23, 9 (September 2011), 1282-1298. 
DOI=10.1109/TKDE.2011.47 
http://dx.doi.org/10.1109/TKDE.2011.47
 121
