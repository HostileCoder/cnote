A Flexible Data Model for Multi-Tenant 
Databases for Software as a Service 
     Gorti Indrani                                  Nematollah Shiri                       Thiruvengadam Radhakrishnan 
Dept. of Computer Science                         Dept. of Computer Science                          Dept. of Computer Science  
    Concordia University                                 Concordia University                                     Concordia University 
    Montreal, Canada                                          Montreal, Canada                                          Montreal, Canada 
i_gorti@ecse.concordia.ca                             shiri@cse.concordia.ca                              krishnan@cse.concordia.ca 
 
Abstract— We study data models for multi-tenant 
databases for Software as a service (SaaS), which is 
important for emerging big data applications. In our 
study we consider the shared table architecture model of 
SaaS for its advantages over the shared machine and 
shared process models. Our goal is to further improve the 
processing time and space utilization of shared table 
model. For this, we introduce a new data model, called 
Index table layout and compare its performance with the 
Chunk table layout. Our model includes an additional 
'index' column in the base table that cross-references via 
the index across supporting tables. Not needing nulls, the 
proposed model enjoys quick access of the values in a 
column. We evaluated the performance of our model, for 
which we crated randomly large data for Chunk table 
layout and from which we then constructed the tables for 
the Index table layout. We also compiled 3 types of 
queries used in our evaluation. Our results show that 
Index table layout is better than the Chunk table layout in 
terms of expressive power, space utilization, and query 
processing time. 
Keywords: Database Design, Management, Performance 
I. INTRODUCTION 
Multi-tenancy is a software architecture principle in 
the realm of the Software as a Service business model. It 
is an optimization for hosted services, which improves 
utilization of resources by providing a uniform 
framework in which multiple clients, the “tenants”, share 
the same application and database instance, hence 
allowing scalability and is cost effective. Aulbach and 
Jacobs [7] compare the three approaches for sharing 
storage, namely shared machine, shared process, and 
shared table. 
 
Compared to the limitations and shortcomings of the 
other two approaches, the shared table approach is 
considered to be more desirable [13]. 
 
Figure 1 illustrates the shared table approach in which 
data from many clients is stored in the same table. A 
Tenant Id column is used to identify each tenant/client, 
i.e., the owner of each row. To allow clients to extend the 
base schema, each table is given a fixed set of additional 
generic columns. While this approach is suitable for 
pooling resources, its ability to scale up is limited by the 
number of rows in the database. Despite this limitation, 
the shared table approach offers much improvement over 
the shared process approach [5]. Administrative 
operations can be executed in bulk simply by executing 
queries that range over the TenantId attribute, and since it 
uses a single database, clients can share connection pools. 
 
Stefan and Jacobs in [13] discuss the various layouts 
proposed for shared table architecture to support a multi-
 tenant scenario. They include Private tables, Extension 
tables, Sparse columns, Pivot tables, and Universal table. 
They also propose a model, called the Chunk table 
layout, in which the metadata is divided among 
application-specific conventional tables and a large fixed 
set of generic structures, called Chunk tables. The 
proposed chunk table is complemented with the concept 
of Chunk folding introduced in [13] which results in 
vertically partitioning of logical tables into “chunks”.  
These “chunks” are folded together into different 
physical multi-tenant tables as and when needed. In a 
follow up work [11], they focus on extensibility and 
versioning. Grund, et al. [9] introduce vertical 
partitioning technique in the case of insert-only queries. 
Bezemer and Zaidman [5] proposed a column store 
approach, which significantly improves space utilization 
and overhead through compression. 
As noted in [2, 3, 4, 5, 6], more work is required before 
an ideal SaaS system is developed. An ideal such system 
should provide a balance in memory consumption and 
query processing time. It is hence necessary to have a 
SaaS system that has a Data Definition Language (DDL) 
component explicitly for supporting schema extensions. 
A desired database system should distribute data for 
many tenants across a farm of servers. The distribution 
should be tenant-aware rather than lumping all tenants 
into one large data set. In particular, the database should 
support multiple communication patterns for joins. Not to 
forget scalability, an ideal such system should be able to 
gracefully handle databases as they grow in data size. 
The vertical storage structures of HBase and BigTable, 
which were used to implement Pivot Tables [13], are 
similar to column stores used for narrow operations over 
many rows. Such vertical structures may be made more 
2013 IEEE 16th International Conference on Computational Science and Engineering
 978-0-7695-5096-1/13 $31.00 © 2013 IEEE
 DOI 10.1109/CSE.2013.154
 1059
competitive for “wide” operations by keeping the data in 
memory. This is because the cost of reassembling rows 
is dominated by the time to perform many reads from 
disk. Advancements in data storage technologies are 
gradually making main-memory databases more 
attractive.  
An ideal model for SaaS applies equally well to main-
 memory databases. This vertical expansion of table 
helps improve the performance of analytics and RDF 
data [13].  We propose the Index table layout, which uses 
column-store feature for a Shared table, multi-tenant 
scenario.  It enjoys the advantages of column store databases 
such as compression, efficient query processing and space 
utilization. It also overcomes the limitations of the Chunk 
table layout for handling certain queries. It can be observed 
in [13] that having vertical structures like HBase is crucial to 
be more effective for wide operations.   
This paper is organized as follows:  Section II covers the 
relevant literature and the background for this work.  Section 
III introduces the proposed Index Table Layout and its 
details.  Section IV presents the performance evaluation of 
the proposed model and finally Section V draws conclusions 
and advantages of the Index Table Layout. 
II. BACKGROUND AND RELATED WORK  
Experiments reported in [9] show transformations needed 
to produce queries over Chunk tables by considering the 
basic case of Pivot Tables and evaluate the efficiency of 
the Chunk folding method. 
 
 The performance of Chunk tables is improved by 
mapping the most heavily-utilized parts of the logical 
schemas into the conventional tables and mapping the 
remaining parts into Chunk tables that match their structure 
as closely as possible. This method, however, is useful in 
case of partitioning data into heavily and non-heavily 
utilized parts.  Each of the models discussed in [14] is built 
from the private table model. In fact, these other models are 
representations of the private tables, however, it is not 
always easy to convert back these tables into the private 
tables.  
 
This reverse mapping is helpful especially if one wants to 
automate the process of converting the data in a source 
schema to cloud database. 
Let us consider the reverse-engineering process for existing 
schema-mapping techniques. In general, the base tables for 
the private table layout have fairly less complex schemas. 
To describe the reverse process, we make our comparisons 
against the Chunk table. 
 
 
 
 
Fig 1. Shared Table Architecture 
 
                           
 
                                     
                                 
 
Fig. 2. Private table layout 
 
 
 
 
           Fig. 3.  Addition of an extra column to the Private Table Account 17 
 
 
 
 
 
 
 
TenantId Name Hospital 
No. of 
Beds 
... Dealers 
17 Acme St. 
Mary 
135 
  
17 Gump State 1042 
  
35 Ball 
    
42 Big Gump 
  
65 
Account 17 
Aid Name Hospital No. of beds Apt 
1 Acme St. Mary 135 4 
     
2 Gump State 1042 3 
Account 35 
Aid Name 
1 Ball 
Account 42 
Aid Name Dealers 
1 Big 65 
Account 17 
Aid Name Hospital No. of Beds 
1 Acme St. Mary 135 
2 Gump State 1042 
Account 35 
Aid Name 
1 Ball 
 Account 42 
Aid Name Hospital Dealers 
1 Big Gump 65 
1060
Though this kind of process is not always required, it may 
still lead to incorrect results.  For instance, when extra 
column of existing data type is inserted in the Private table 
[14], the corresponding update has to be done on the Chunk 
table layout. Figure 3 illustrates this update. If we were to 
include another column to Account 17 with a data type, 
e.g., “int”, which already exists we should update the 
Chunk table, if used as the cloud data schema. Since, in the 
Chunk table Layout we have the data differentiated by their 
types, we have to place ‘4’ in the column ‘int’ with the 
corresponding entries being Tenant-0, Table-0, Row-0. It 
can be observed that the Chunk column of the Chunk table 
layout does not matter in this case as it determines to which 
of the Chunks it belongs. Note that the Chunks are 
determined by how heavily the tables are utilized 
            
Figure 4: Updated Chunk table with extra column 
     
             Fig.  5. Extended Pivot Table 
 
 
Note that when inserting 4 as a new value in column Int1, it 
can replace the entry 135, shown in Figure 4. Besides, the 
Str1 value corresponding to 4 is not provided.  
Furthermore, columns Tenant, Table, and Row have the 
same values. As a result, if one wants to construct the 
Private Table afresh from this model, there will be a 
problem of ambiguity. In case of an automated process, this 
may lead to information loss, which is not acceptable. 
In addition to the aforementioned problem, the Chunk table 
layout assumes that values of similar data types cannot be 
repeated. To illustrate this, consider the following query, 
taken from [13]: 
    SELECT Beds 
    FROM (SELECT Strl AS Hospital, Intl AS Beds  
    FROM Chunkintlstr WHERE Tenant = 17 AND  
    Table = 0 AND Chunk = 1) AS Accountl7  
    WHERE Hospita1=`State’; 
Here, since both ‘Name’ and ‘Hospital’ are stored under 
column Str1, the condition Hospital = ‘State’ means 
looking for any entry in that column with value ‘State’. 
This results in incorrect query result if there were another 
value, say ‘State’, under the column ‘Name’ in the Private 
table model (i.e., the corresponding entry would also be 
under the column Str1 in the Chunk table). This is a 
drawback of this model as we may have entries in a table 
with the same values under different attributes. 
In this paper, we introduce a new data model that improves 
upon the Chunk table layout. A first step to address this 
problem, is to eliminate the Chunk column altogether and 
add a column, called ‘Col’. This column pertains to the 
number of column of the private table in which the value is 
placed. Because of this change, there is a considerable 
change in the schema, as follows. Instead of having both 
columns Int1 and Str1 in the same column which will cause 
ambiguity, we just have one column Value for each entry in 
the table. Figure 5 shows the new table, called Extended 
Pivot table, which is a combination of Pivot and Chunk 
tables [14]. 
Hence with the coordinates being Col, Row, Table, and 
Tenant, it is straightforward to map the values from the 
Extended Pivot Table back to the Private Table.  There is 
now a one to one correspondence between every value in 
the Extended Pivot table and the private tables. Note that 
for every value in the table there is a metadata of four 
coordinate values.  This is a fairly simple model. The 
queries over this model are less expensive; they are over 
the Tenant column with a series of AND operations. 
However it is not space efficient. In terms of space taken 
for the metadata, we perform almost the same. We can 
further improve the Extended Pivot model keeping in mind 
the query rewriting aspect. This is discussed next.  
 
 
 
Chunk int|str  
Tenant Table Col Row Value  
17 0 0 0 1  
17 0 1 0 Acme  
17 0 2 0 St. 
Mary 
 
17 0 3 0 135  
17 0 4 0 4  
35 1 0 0 1  
35 1 1 0 Ball  
42 2 0 0 1  
42 2 1 0 Big  
42 2 2 0 65  
Chunk int|str 
Tenant Table Chunk Row Int1 Str1 
17 0 0 0 1 Acme 
17 0 3 0 135 St. 
Mary 
17 0 0 1 2 Gump 
17 0 3 1 1042 State 
17 0 3 0 4 ? 
35 1 0 0 1 Ball 
42 2 0 0 1 Big 
42 2 2 0 65 - 
1061
III.  THE PROPOSED INDEX TABLE LAYOUT 
The proposed Index table layout improves the performance 
in terms of processing time and space utilization. Figure 5 
illustrates the Index table layout. The base table and the 
supporting tables in the queries are ext_base, ext_dealers, 
ext_hospital, and ext_beds. The proposed Index layout is 
illustrated in Figure 6. It includes a base table that contains 
all the columns that are common to all the individual multi-
 tenant tables (Private tables) with an additional column, 
called the ‘Index’. The tuples in the schema are the tuples 
related to all the tenants. The index column is defined as 
NOT NULL and UNIQUE KEY, and is incremented 
automatically with insertion of each tuple. Hence in our 
example, the Index table layout would have the attributes 
Index, Tenant, Aid, and Name. Apart from the base tables, 
we have other supporting tables, each having two columns, 
one for the ‘Index’ and the other for the unique columns. 
 
 
 
Fig. 6.  Index Table Layout 
In other words, if there are n non-common columns among 
the private tables, we would have n supporting tables along 
with a base table. As a part of representation, only the valid 
and existing records go into the supporting tables and these 
rows have a matching ‘Index’ value from the base table. In 
Figure 2, for instance, when the index is 2, it means Tenant 
17 has a value with Aid as 2, Name as ‘Gump’, Hospital as 
‘St. Mary’, and the number of Beds ‘1042.’ Since there are 
no dealers for ‘Gump’ we totally avoid writing a Null value 
or reserving a place for it in the supporting table for dealers. 
This will not only avoid the problem of sparsely populated 
tables but also enable writing only the values that are 
required. 
This way, there is one to one correspondence between 
values in the Index Layout and the Private Table Layout. 
.Hence, rewriting back the Index table layout to the Private 
table is possible when automated. In terms of queries, this 
layout can give faster results to queries with predicates on 
columns. An example would be: “Give the names of all 
hospitals.” This is a select distinct operation over the 
supporting table for Hospitals. This would have otherwise 
been a complex query consisting of many AND operations 
over several conditions on columns Tenant, Row, Col, 
Int1, Str1 with values, each of which ranging and 
changing over many figures. Hence, with respect to both 
correctness and clarity, the Index Layout is an option 
over the Chunk tables, Pivot tables and Extended Pivot 
tables.  Addressing queries that are common over all the 
tenants are obviously queried upon the base table over the 
tenant id. So the queries are not complex. The worst case 
query would be the only query that has a join operation over 
all the tables with the predicate on the ‘Index’ value. Hence, 
the Index table layout improves both upon the space and 
query processing. 
The advantages of the proposed Index table layout include 
better space utilization for not needing nulls, fast access of 
the values in a column, and indexing.  The worst case 
scenario would be when performing a join operation over 
all the supporting tables, which is expensive. Thus the 
number of joins is equal to the number of supporting 
columns for the worst case scenario. 
IV. EXPERIMENTS AND RESULTS 
We conducted experiments using MySQL Workbench 5.2 
CE using an Intel Xeon Processor with 4 GB RAM. In 
order to simulate the test beds, the schema for the Private 
tables were first created. The schema for Chunk and Index 
table layouts are created next. The data is generated for all 
the layouts so as to maintain the equivalence of data 
between both the layouts. In order to do this, many scripts 
were written. Perl and Shell scripting was used for 
generation of data.  We first wrote scripts to randomly 
generate large data for the Chunk table layout and then 
constructed the individual tables and the tables for Index 
table layout from this data. Hence, there is a one to one 
correspondence between data in the private tables and the 
data in the index and Chunk table layouts. 
The Database layout is an OLTP schema with one-to-many 
relationships. Individual users within a business (a tenant) 
are not modeled, but the same tenant may engage in several 
simultaneous sessions so data may be concurrently 
accessed. Every table in the schema has a tenant-id column 
so that it can be shared by multiple tenants.  Each of these 
tables contains about 20 columns, one of which is the 
Base Table 
Index Tenant Aid Name 
1 17 1 Acme 
2 17 2  
Gump 
3 42 1 Big 
4 35 1 Ball 
Index Number of Beds 
1 135 
2 1042 
Index Hospital 
1 St. Mary 
2 State 
3 Gump 
Index Dealers 
3 65 
1062
entity’s ID. Every table has a primary index on the entity 
ID and a unique compound index on the tenant ID and the 
entity ID. The experiments include CRUD operations and 
reporting tasks that simulate the daily activities of 
individual users. To facilitate the analysis of experimental 
results, the queries are grouped ranging from light weight 
actions to heavy actions. These can be seen in queries of 
Type 1. We first construct a Chunk table that has 104 rows 
and constructed the appropriate Private and Index tables. 
We then keep increasing the number of tuples by multiples 
of ten. We compare the results of the Chunk tables with 
104, 105, 106, 107, and 108 tuples and their corresponding 
tables represented in our Index model. 
While we have considered all the queries that were used to 
test in the evaluation phase of [13], we also discuss a 
variety of other queries. We compare the two models based 
on expressivity and flexibility with which one can 
formulate queries, and on efficiency of query processing. 
As mentioned earlier, the Chunk table is limited in its 
modeling capabilities. We also note that the Chunk table 
layout can be constructed from the Private table layout, but 
the reverse is not possible. 
We considered different types of queries in performance 
evaluation of different data models. A classification of 
query types is as follows, together with an explanation of 
why such queries were considered. 
Note that in all the graphs logarithmic scale is used to 
accommodate values.  This is because in most of the cases 
the execution times is a fraction of a second and hence the 
values fall below the axis.  For maintaining uniformity and 
to accommodate a large range of values (say, values from 
0.1 to  90,000 seconds),  logarithmic scale has been used in 
all our graphs.  So, throughout this paper, for a bar graph 
showing execution times falling below the axis, it  
represents a fraction of a second. 
Type 0: These are queries supported by Chunk table layout 
and our proposed Index table layout. 
We observe that for Chunk table layout, it is not possible to 
pose a query that retrieves information for a predicate over 
two or more columns. Since queries require values of the 
columns from meta-data columns (like row, col, table) and 
the values of meta-data columns are usually not constant 
and there is clear ambiguity in values under different 
columns. Hence queries that can be posed both against the 
Chunk table and Index table layouts are simple select 
queries. It should be noted that most queries in SaaS are 
usually over single columns or involve simple predicates. 
Comparison of fetch times between Chunk and Index table 
layouts is shown in Figure 8. It indicates that the fetch 
times of Index table layout improve upon the Chunk table 
layout by about a degree of magnitude. 
Type 1: These are queries found and collected from the 
related literature.  
In [12] the authors compare performance of Chunk table 
layout using different DBMSs. For this, they considered 
types of queries on attributes for various layouts such as 
Private and Extension layouts. The query types used in 
their experiments were Select 1, Select 50, Select 1000, 
Insert 1, Insert 50, Update 1, and Update 100 attributes, 
evaluated against different layouts. Figures 9 shows the 
comparison of fetch times between Chunk and We have 
only shown Type 1 for 104 tuples here. It can be observed 
that for Type 1 queries, the performance of Chunk table 
and Index table layouts are almost the same. 
Type 2: These are queries supported by the Index table 
layout only.  
A drawback of Chunk table layout is that queries including 
predicates on different columns are not possible to express. 
This limits expressive power of the model, in that user 
and/or service provider cannot formulate a variety of 
queries. In our experiments, we have compiled a list of 
queries consisting those used in the experiments reported in 
[13] and additionally from ours. We record the fetch times 
for tables of tuple with size ranging from 104 to 108 tuples. 
Appropriate configuration settings have been set in 
MySQL (my.ini in windows and my.cnf in linux) to 
support large tuple sized tables in the experiments. Figure 
10 illustrates: Performances of different queries of Type 2 
for tables of different tuple sizes.  
We used the following queries in our experiments. They 
include the queries as defined and used in [13], and new ones 
as Type 2 queries we define in our context of this work. We 
remind that these queries could not be posed for the Chunk 
table layout. 
Query1: Select distinct names of hospitals.  
For the Index table layout, this query may be expressed as 
follows: 
		

 Formulating a corresponding query for the Chunk table 
layout is not possible. This is because we query over the 
column Str1 which accepts any value of the type String. 
These entries need not necessarily be the entries 
corresponding to the same column in the Private table 
layout. Having predicates over the columns Chunk, row, 
table, and tenant do not help either. 
Query 2: Find the number of entries for tenant 17. 
Query formulation for the Index table layout would be:  
      
 !""#$% 
For the Chunk table, this query could be expressed as 
follows: 
1063
      
 
&"'"( !""#$%
 However, this does not return the result expected, explained 
as follows. The number of tuples in the Chunk table grows 
as the number of columns in Private table grows. In our 
running example, since each tuple is represented in two 
columns in the Chunk table, we cannot assume that the 
number of entries for Tenant 17 would be a multiple of a 
fixed number (2, in our case). 
Query 3: List the hospitals and their number of beds. 
For the Index table layout: 
)"&*(+
 ,	
+

 -	"++#+-	"+	+.

 -#//
 For Chunk table layout, this query could be expressed as: 
"&*(+
 ($.)	"$.+
 &"'"( !""#$%
  !#0/
 Note a restriction here which assumes, by default, that State 
is assumed is of type Str1, which may not be true. 
Query 4: Find the number of beds for Tenant 17. 
For the Index table layout, this query is formulated as 
follows: 
"&*(+
 +)
  !+-	"++#-	"+	+
 The above query could not be expressed for the 
Chunk Table layout since selecting any value from the 
attribute “Int1” would include values corresponding to other 
possible attributes of all the tenants. 
Query 5:  Find details of tenant, aid, name, and hospitals. 
For the Index table:  
"")+)"*)
 ,	


 -	"++#-	"+	+
  
This query cannot be expressed over the Chunk Table 
layout.  
Query 6: Find details of hospitals and beds for each 
tenant. 
This query for the Index table layout can be expressed as 
follows, which includes two join operations over the 
common attributes among the tables, namely ext_base, 
ext_hospital, and ext_beds. 
"")+)"*))"&*(+
 ))+
  !-	"++#-	"+	+
 .
-	"+	+#+-	"++
 This query is not possible to express for the Chunk 
Table layout. This is because in a Chunk table, data 
values of similar type are stored in one column, and 
hence having predicates over Tenant, Chunk, and row in 
the WHERE clause do not help in retrieving the right 
data.While queries of types 0, 1, and 2 measure 
expressivity of the schema, we also compare the Chunk 
table and Index table layouts based on their space 
requirements. In the Index table layout, common data 
among tenants is always stored in the base table. The 
supporting tables would only include necessary rows. This 
reduces the space utilization to a large extent. We hence 
compare the sizes of Chunk table and the Base table of the 
Index table layout. Figure 7 illustrates the results of this 
comparison. 
V. CONCLUSION 
We studied suitable date models for multi-tenant 
databases, which is important to manage big data in the 
context of cloud computing paradigm. We proposed a 
data model that improves chunk model in space 
utilization as well as query processing. The correctness 
of the proposed model was discussed and illustrated 
through various query types. 
We note that in terms of space, the Index table layout 
takes almost two third of the space taken by the Chunk 
table layout. We observe that the query processing times 
of Index table layout for queries of Type 0 improve by 
an order of magnitude. We also observe that the query 
processing times for queries that can be posed both 
against the Chunk table and the Index table layout (Type 
1) are almost the same. We compile an exhaustive set of 
queries as Type 2. These queries could not be supported 
by the Chunk table layout. This is due to the inflexibility 
of the Chunk table layout and poor design. Since the 
Index table layout is a vertically partitioned schema, we 
can take advantage of column store features. This is an 
advantage as most of the queries for SaaS are posed on 
individual columns. 
The index column of the base table can be further 
indexed, sorted or even hashed if the application 
demands.  This is useful in case the schema has to be 
1064
further extended to a data warehouse like application 
scenario as many CUBE operations involve individual 
columns. The result of our experiments and 
analyses indicate that our proposed Index layout is 
more expressive than the Chunk table layout, and 
results in much improvement in performance in terms 
of space utilization through compression and is more 
expressive for supporting a wider range of query 
types. Its vertical partitioning and its column-store 
like design leads to significant increase in query 
processing performance. Other advantage of the Index 
table layout is that the mapping step of the Index table 
is much less complicated than that of Chunk Folding. 
  
 
 
     Figure 7. Comparisons of sizes of Chunk and Index Table layouts 
 
 
                                         Fig. 8.  Comparison of fetch times of Chunk and Index table layouts for Type 0 queries 
 
 
 
Fig. 9. Comparison of fetch times of Chunk and Index table layouts for 105 tuples and Type 1 queries 
 
 
1065
 
 
Fig. 10. Performances of different queries of Type 2 for tables of different tuple sizes 
 
 
ACKNOWLEDGEMENTS 
This work was partially supported by grants from Natural 
Sciences and Engineering Research Council (NSERC) of 
Canada and by Concordia University 
REFERENCES 
[1] D.J. Abadi, A. Marcus, S. Madden, and K.J. 
Hollenbach. Scalable Semantic Web Data Management 
Using Vertical Partitioning. In Proc. of the 33rd Int’l Conf. 
on Very Large Data Bases (VLDB), pages 411-422, 
Vienna, Austria, September 23-27, 2007. 
[2] R. Agrawal, A. Somani, and Y. Xu. Storage and Querying 
of E-Commerce Data. In Proc. of the 27th Int’l Conf. on 
Very Large Data Bases, pages 149–158, September 11-14, 
2001. 
[3] J.L. Beckmann, A. Halverson, R. Krishnamurthy, and J.F. 
Naughton. Extending RDBMSs to Support Sparse Datasets 
Using an Interpreted Attribute Storage Forma. In Proc. of 
the 22nd IEEE Int’l Conf. on Data Engineering (ICDE), 
page 58, Washington, DC, USA, 2006. 
[4] P.A. Boncz. Monet: A Next Generation DBMS Kernel for 
Query-Intensive Applications. Ph.D. Thesis, Universiteit 
van Amsterdam, Amsterdam, The Netherlands, May 2002. 
[5] C. Bezemer and A. Zaidman. Multi-tenant SaaS 
Applications: Maintenance Dream or Nightmare. In Proc. 
Of the Joint ERCIM Workshop on Software Evolution 
(EVOL) and Int’l Workshop on Principles of Software 
Evolution (IWPSE), pages 88-92, Antwerp, Belgium, 
September 20-21, 2010. 
[6] C. Cunningham, G. Graefe, and C.A. Galindo-Legaria. 
PIVOT and UNPIVOT: Optimization and Execution 
Strategies in an RDBMS. In Proc. of the 13th Int’l Conf. 
on Very Large Data Bases (VLDB), pages 998-1009, 
Toronto, Canada, August 31-September 3, 2004. 
[7] D. Jacobs and S. Aulbach. Ruminations on Multi-tenant 
Databases. In Proc. of Business Technology and Web 
(BTW), pages 542-561, Aachen, Germany, March 2007. 
[8] F.S. Foping, I. M. Dokas, John Feehan, and S. Imran. A 
New Hybrid Schema-Sharing Technique for Multitenant 
Applications. 
http://4c.ucc.ie/web/upload/publications/inProc/PID1027 
507.pdf (Oct. 15, 2012) 
[9] M. Grund, J. Krueger, C. Tinnefeld, A. Zeier. Vertical 
Partitioning in Insert-Only Scenarios for Enterprise 
Applications. In Proc. of  IEEE 16th Industrial Engineering 
and Engineering Management (IE &EM), Beijing, China, 
21-23 Oct. 2009 
[10] M. Stonebraker, D.J. Abadi, A. Batkin, X. Chen, M. 
Cherniack, M. Ferreira, E. Lau, A. Lin, S. Madden, E.J. 
O’Neil, P.E. O’Neil, A. Rasin, N. Tran, and S.B. Zdonik, 
C-Store: A Column-oriented DBMS. In Proc. of the 31st 
Int’l Conf. on Very Large Data Bases (VLDB), pages 553- 
564, Trondheim, Norway, August 30- September 2, 2005 
[11] S. Aulbach, M. Seibold, D. Jacobs, and A. Kemper. 
Extensibility and Data Sharing in Evolving Multi-Tenant 
Databases. In Proc. Int’l Conf. of Data Engineering 
(ICDE), Hannover, Germany, April 11-16, 2011. 
[12] S. Aulbach, M. Seibold, D. Jacobs, and A. Kemper. A 
comparision of flexible schemas for Software as a Service. 
In Proc. Of the ACM Int’l Conf. of Management of Data 
(SIGMOD), Rhode Island, USA, June 29-July2, 2009. 
[13] S. Aulbach, T. Grust, D. Jacobs, A. Kemper, and J. 
Rittinger. Multi-tenant databases for software as a service: 
schema mapping techniques. In Proc. of the ACM 
SIGMOD, pages 1195–1206, Vancouver, Canada, June 9-
 12, 2008. 
 
1066
