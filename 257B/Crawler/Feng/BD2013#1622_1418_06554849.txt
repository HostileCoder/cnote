Secure and efficient mutual authentication protocol
 for RFID conforming to the EPC C-1 G-2 Standard
 Liaojun Pang
 School of Life Sciences and Technology
 Xidian University
 Xi’an, 710071 China
 Email: ljpang@mail.xidian.edu.cn
 Liwei He, Qingqi Pei, Yumin Wang
 State Key Laboratory of Integrated Service Networks
 Xidian University
 Xi’an, 710071 China
 Abstract—As low-cost tags based on the EPC C-1 G-2 s-
 tandard are much limited in storage capacity and computation
 power, most of the existing authentication protocols are too
 complicated to be suitable for these tags, and the design of
 authentication protocols conforming to the EPC C-1 G-2 standard
 is a big challenge. Recently, a mutual authentication protocol for
 RFID conforming to the EPC C-1 G-2 standard was proposed
 by Yeh et al., and it is claimed that this protocol has solved all
 security vulnerabilities in the existing RFID protocols. However,
 in fact, it is proven that this scheme is vulnerable to the tag tracing
 attack and suffers from the information leakage issue, and the
 complexity of the successful attack is only 216. To address these
 issues efficiently, a novel secure RFID authentication protocol
 conforming to the EPC C-1 G-2 standard is proposed. In the new
 scheme, the attack complexity is raised to 232 without changing
 the length of any protocol data. Analysis shows that our protocol
 can not only efficiently resist the tag information leakage and
 the tag tracing attack, but also have a significant advantage in
 performance over Yeh et al.’s protocol.
 Keywords—RFID; EPC C-1 G-2 standard; privacy; security;
 I. INTRODUCTION
 Nowadays, with the development of logistics and ecom-
 merce, the Radio Frequency Identification (RFID) technology
 has been employed in many applications such as public trans-
 portation pass, supply chain management, e-passport, access
 control system and etc. The RFID technology is a passive
 automatic identification technology that uses radio signals to
 automatically identify the target and obtain its relevant data
 without human intervention and can work in all kinds of harsh
 environments. In an RFID system, the reader communicates
 wirelessly with a RFID tag via radio frequency signals, which
 makes the RFID system vulnerable to the tag impersonation
 attack, the tracing attack, the replay attack, the DoS (denial of
 service) attack, the eavesdropping attack, and so on. So, the
 security problem has become an obstacle to using the RFID
 technology widely.
 To heal these security weaknesses existing in the RFID
 system, many researchers have paid more attention to the
 RFID authentication protocols based on cryptographic mech-
 anisms in the early research of the RFID security mechanism.
 Nevertheless, due to the storage and computation limitation
 of the low-cost tags, it is not realistic to design a protocol
 based on complicated cryptographic algorithms. At present,
 it is commonly accepted to use the Hash function, whose
 computation overhead is relatively small to authenticate tags
 and the reader, in low-cost RFID security authentication
 schemes [1], [2]. However, the EPC Class-1 Generation-2
 (short as EPC C-1 G-2) standard, which is suitable for low-cost
 RFID tags and proposed by EPC (Electronic Product Code)
 global organization [3], defines a much stricter framework
 including the tags’ functions and operations. In the EPC C-
 1 G-2 standard, the allowable operations of tags are restricted
 to some simple operations such as CRC (Cycle Redundancy
 checksum Code), PRNG (Pseudo Random Number Generator),
 and bitwise XOR, and even the Hash operation is not avail-
 able under this definition [4], [5]. In this case, those RFID
 authentication protocols based on the Hash function are too
 complicated for EPC C-1 G-2 tags [6]. Therefore, the design
 of RFID authentication protocols conforming to the EPC C-1
 G-2 standard becomes one of hot topics of the RFID security
 protocol.
 Most of the existing RFID authentication protocols con-
 forming to the EPC C-1 G-2 standard have undergone some
 difficulties to provide the security. It usually introduces new
 problems when trying to solve some potential ones. Juels [7]
 proposed an anti-cloning and anti-counterfeiting RFID authen-
 tication protocol conforming to the EPC C-1 G-2 standard
 in 2005. However, Duc et al. [5] pointed out that there are
 some weaknesses related to privacy and information leakage in
 Juels’ scheme. And at the same time, Duc et al. [5] proposed
 a new scheme, which only used CRC, XOR and PRNG to
 guarantee the interactive information security, and declared
 it can achieve mutual authentication between the tag and the
 reader as well as the synchronous updating of secret key. But
 later, researchers found that Duc et al.’s protocol is prone to
 the de-synchronization attack and it cannot ensure the forward
 security. Chien and Chen [8] proposed an improved RFID
 authentication protocol (referred as CC) in 2007. But soon
 after that, Lopez et al. [9] pointed out that the CC scheme
 cannot resist the tag and reader impersonation, tracing and
 de-synchronization attacks. Han and Kwon [10] also showed
 clearly in another way that the above attacks of the CC scheme
 results mainly from the linear attributes of CRC. In 2010,
 Yeh et al. [11] proposed a secure RFID mutual authentication
 protocol (referred as SRP). The SRP scheme uses the tag
 index number to search the target tag from the database,
 and it improves the efficiency of the database to identify
 tags. However, Habbie et al. [4], [17] found its drawbacks
 978-1-4673-5939-9/13/$31.00 ©2013 IEEE
 2013 IEEE Wireless Communications and Networking Conference (WCNC): NETWORKS
 1870
TABLE I. NOTATIONS
 Name Meaning
 EPCs A 16-bit value which is built by XORing six 16-blocks of the EPC code
 Ki The authentication key stored in a tag and used to authenticate the tag at (i+1)th authentication by the database
 Pi The access key stored in a tag and used to authenticate the database at the (i+1) authentication by the tag
 Ci The database index stored in the tag and used to find the corresponding record of the tag by the database
 RID The identity number of the reader
 Pold The old access key stored in the database
 Pnew The new access key stored in the database
 Kold The old authentication key stored in the database
 Knew The new authentication key stored in the database
 Cold The old database index stored in the database
 Cnew The new database index stored in the database
 Di The detailed information of the tag stored in the database
 soon as well as Eun-Jun Yoon [16]. Besides, we find that
 the SRP scheme may leak the secret key and an adversary
 can easily get the shared secret key via a simple passive
 attack. In addition, the SRP protocol does not accord with the
 common assumptions of the RFID authentication protocol, and
 the authentication operations between the reader and the back-
 end server are not necessary, because they are usually wired
 connected, and the communication between them is assumed
 to be secure [3], [5], [8], [12], [13].
 Motivated by these concerns, a new RFID authentication
 protocol conforming to the EPC C-1 G-2 standard is proposed.
 The rest of the paper is organized as follows. In Section 2, the
 authentication process of the SRP protocol is introduced and
 some analyses are made on them. Then, our RFID authenti-
 cation protocol conforming to the EPC C-1 G-2 standard is
 proposed in Section 3. In Section 4, the security and privacy
 of our protocol is analyzed with given security models. Finally,
 we put forward the related conclusions in Section 5.
 II. VULNERABILITIES OF THE SRP PROTOCOL
 A. Review of the SRP protocol
 The notations used in the SRP protocol are introduced in
 Table I, and the process of the SRP protocol [11] is simply
 described as follows:
 1) Initialization
 For each tag, the database is preloaded with the entry
 [Kold,Pold,Cold,Knew,Pnew,Cnew,EPCs,RID,Di]. The values
 K0, P0 and C0 are generated randomly by the manufacturer.
 And initially, we set Kold = Knew = K0, Pold = Pnew = P0,
 Cold = Cnew = C0. Each tag records the entry [Ki = K0,
 Pi = P0, Ci = C0, EPCs] which have the same values as
 those recorded in database.
 2) The (i+ 1)th authentication round
 First, the reader queried the tag T with a random number
 NR. Then, the tag T responds to the reader’s query by
 computing
 M1 = PRNG(EPCs  NR) Ki
 D = NT  Ki
 E = NT  PRNG(Ci  Ki)
 and sending M1, D, E and C to the reader. Then, the reader
 transmits M1, D, E and C to the server.
 The server computes M2=PRNG(EPCs NT ) PX (where
 X=new or old) and Info=Di RID, and sends them to the
 reader after successfully authenticating the tag, and at the same
 time updates Ki, Pi and Ci as follows:
 If X=new, it updates the stored values as follows:
 Kold = Knew;Knew = PRNG(Knew)
 Pold = Pnew; Pnew = PRNG(Pnew)
 Cold = Cnew; Cnew = PRNG(NT  NR)
 If X=old, it only updates Ci as Cnew =PRNG(NT  NR).
 At last, the reader transmits M2 to the tag.
 After authenticating the server successfully, the tag updates
 Ki, Pi and Ci as follows:
 Ki+1 = PRNG(Ki)
 Pi+1 = PRNG(Pi)
 Ci+1 = PRNG(NT  NR)
 B. Vulnerabilities of the SRP protocol
 Habibi et al.[4] shows that the SRP protocol does not
 provide the forward security (or called the backward untrace-
 ability) and the untraceability. Aside from the tracing attacks,
 it is presented that an adversary can obtain the most important
 secret information value called EPCs by impersonating the
 reader to perform two consecutive sessions with the target tag.
 Upon having got the correct EPCs, the adversary can figure
 out the shared secret value of Ki and successfully impersonate
 the tag for ever. In addition, the reveal of EPCs can lead to
 the DoS attack and the Server Forgery attack (see [4], [16],
 [17] for details).
 In addition to the above attacks proposed by Habibi et al.,
 we present a simple passive attack which also can break the
 SRP protocol, and this attack makes it possible for an adversary
 to get the Ki. Here, we will present this attack. In the SRP
 protocol, it is mentioned that the value EPCs is a 16-bit string
 which is constructed from XORing six 16-bit blocks of the
 EPC code. Since NR and NT are XORed with EPCs, it is
 concluded that the bit lengths of NR and NT are the same as
 the bit length of EPCs which is 16. Since Ki, Pi and Ci are
 updated by PRNG, the bit lengths of them must be equal to
 the output length of PRNG which is 16.
 The process of the simple attack is shown as follows:
 1) The adversary intercepts the responding message
 (Ci;M1; D;E) of the tag in the i-th session, and the structure
 of the messages D and E are as follows:
 D = NT  Ki
 1871
E = NT  PRNG(Ci  Ki)
 2) The adversary omits NT by XORing D and E:
 D  E = NT  Ki  NT  PRNG(Ci  Ki)
 = Ki  PRNG(Ci  Ki) =  
where  is a 16-bit string equal to D  E in value.
 3) Let L = fl1; l2; :::; l16g be the set of all bit strings with
 length 16. Since Ki is a bit string with length 16, we have
 Ki 2 L. With  and Ci, the adversary continues the below
 algorithm:
 a) Choose li 2 L, for 1  i  216;
 b) Compute  = li PRNG(Ci  li);
 c) If  =  , then return li as Ki.
 After at most 216 executions of the algorithm, the adversary
 can find the correct Ki. As a result, it is easy to see that the
 SRP protocol cannot resist the tag information leakage and the
 tracing attack. In addition, we can see the attack complexity
 of our method is equal to that of Habibi et al.’s, i.e. 216.
 III. THE PROPOSED PROTOCOL
 The SRP protocol is not suitable for practical applications
 because it does not accord with the common assumptions
 of the RFID authentication protocol. Thus here, the common
 assumptions of RFID authentication protocol are introduced
 first, and then the RFID privacy model is given in this section.
 And at last, the proposed protocol is described in details.
 A. Common Assumptions
 Our protocol works under the following assumptions [3],
 [5], [8], [12], [13]:
 1) Each tag has a unique initiator (for example the manu-
 facturer), which creates and maintains security parameters for
 the tag.
 2) Each tag and the reader have a PRNG function. The tag
 can generate random numbers and perform the CRC operation,
 and their memories are assumed to be secure.
 3) The channel between the server and the reader is secure.
 This assumption is reasonable because unlike the tag, the
 reader’s performance is unlimited and thus it can set up a
 secure channel with the server by using those known security
 protocols which have been proved secure (or directly using
 wired connection). So, the algorithm used by them is not
 restricted to the equipments’ performance, and the use of the
 complicated and secure cryptographic algorithms can raise
 the system security largely as a result. After all, the simple
 algorithm and the protocol’s security are relative to the cost of
 the equipments when designing some security protocols related
 to tags.
 4) The reader and the tag communicate over an insecure
 channel and the communication between them is subject to
 eavesdropping or modification.
 B. Privacy Model
 The privacy model [4], [14], [15], [17], [18], [19] is
 described as follows:
 The protocol parties are composed of tags (T ) and readers
 (R) which interact each other in each protocol session. In this
 model, an adversary A controls the communication channel
 between all parties either passively or actively. The Adversary
 A is allowed to run the following queries:
 1) Execute(R; T; i) query: This query models the passive
 attacks. The adversary A eavesdrops over the communication
 channel between T and R and gets the read access to the
 exchanged messages between them in session i of a truthful
 protocol execution.
 2) Send(U; V;m; i) query: This query models active attacks
 by allowing the adversary A to impersonate some readers
 U 2 R (respectively V 2 T ) in some session i and send a
 message m to some tag V 2 T (respectively reader U 2 R).
 Furthermore, the adversary A is allowed to block or alert the
 message m.
 3) Corrupt(T;K 0) query: This query allows the adversary
 A to learn the stored secret K of the tag T , and which further
 sets the stored secret to K 0. Corrupt query means that the
 adversary A has physical access to the tag, i.e., the adversary
 can tamper with the tag’s permanent memory.
 4) Test(i; T0; T1) query: This query does not correspond to
 any of the A’s capabilities, but it is necessary to define the
 untraceable test. When this query is invoked for session i, a
 random number b 2 f0; 1g is generated and then, A is given
 Tb 2 fT0; T1g. Informally, A wins if he can guess the bit b
 correctly.
 Untraceable privacy (UPriv) is defined by using the game
 g played between an adversary A and a collection of session
 instances between the reader and the tag. The game g is divided
 into three following phases:
 Phase 1 (Learning): A is given T0 or T1 randomly and A
 is able to send any Execute, Send and Corrupt queries at will
 to T0, T1 and readers.
 Phase 2 (Challenge):
 1. At some point during g, A chooses two fresh tags T0 and
 T1 to be tested and sends a Test(i; T0; T1) query. Depending
 on a randomly chosen bit b 2 f0; 1g, A is given a tag
 Tb 2 fT0; T1g.
 2. A continues making any Execute, Send and Corrupt
 queries at will.
 Phase 3 (Guess): Eventually, A terminates the game g
 simulations and outputs a bit b0 2 f0; 1g, which is the guess
 value of b.
 The success of A in winning the game g and thus breaking
 the notion of UPriv is quantified in terms of A’s advantage in
 determining what A receives is T0 or T1. The advantage is
 denoted by AdvUprivA (k):
 AdvUprivA (k) = jPr(b
 0 = b) 1=2j;
 where k is the security parameter.
 Definition 1: A protocol is secure, if the advantage
 AdvUprivA (k) of the adversary is negligible.
 C. Description of the proposed protocol
 The notations used in the proposed protocol are the same as
 the SRP protocol (in Table I). Based on the common assump-
 tions presented in Section III-A, a new RFID authentication
 protocol conforming to the EPC C-1 G-2 standard is proposed
 to solve the security problems existing in the SRP protocol.
 1872
Fig. 1: The process of the proposed protocol
 The protocol is summarized in Fig. 1. The process of the
 protocol is divided into the initialization and the authentication
 process.
 1) Initialization
 For each tag, the database is preloaded with the entry
 [Kold,Cold,Knew,Cnew,EPCs,Di]. The values K0, P0 and C0
 are generated randomly by the manufacturer. Then, we set
 Kold = Knew = K0, and Cold = Cnew = C0. Each tag
 records the entry [Ki = K0, Ci = C0, EPCs], whose values
 are equal to those recorded in the database. The reader, which
 is trusted as a party by the server, does not need to store any
 identity information.
 2) AuthenticationProcess
 a) Reader : A reader R generates a random number N1
 and sends it to a tag Ti.
 b) Tag : The tag Ti generates a random number N2, and
 computes:
 M1 = EPCs  N1  Ki
 CN2 = N2  PRNG(Ki)
 M2 = CRC(EPCs  N2  Ci) Ki
 c) Reader : The reader R transmits
 (Ci;M1; CN2;M2; N1) to the server.
 d) Server : The server completes the following steps
 upon receiving (Ci;M1; CN2;M2; N1):
 (i) Based on the received value Ci, the server retrieves
 the database for a Cinew or Ciold equal to Ci and picks
 up EPCs of the correct tag, and then recovers Ki by
 Ki =EPCs N1  M1. If Ki =Kold or Knew, the server
 figures out the temporary key N2 = CN2 PRNG(Ki) and
 checks whether the equation M2 Ki =CRC(EPCs N2 Ci)
 holds or not. The execution of the above process is repeated
 until the matched tag is found. Otherwise, the server sends an
 error message to the reader and stops this session.
 (ii) After authenticating the tag successfully, the sever
 computes M3 =CRC(EPCs  (N2  l=4)) Ki, and sends
 (Di;M3) to the reader R.
 (iii) The server updates the records as follows:
 Ciold  Ci; Cinew  PRNG(N1  N2) Ki
 Kiold  Ki;Kinew  Ki  (N2  l=4)
 e) Reader : The reader R receives (Di;M3) and then sends
 M3 to the tag Ti.
 f) Tag : The tag Ti computes CRC(EPCs  (N2  
l=4)) Ki and checks whether the equation and checks whether
 the equation
 M3  Ki = CRC(EPCs  (N2  l=4))
 holds. If it holds, the tag authenticates the server successfully
 and updates the records as follows:
 Ci  PRNG(N1  N2) Ki
 Ki  Ki  (N2  l=4)
 If it does not hold, the tag Ti stops the session.
 IV. ANALYSES AND DISCUSSIONS
 A. Security Analysis
 Based on the privacy model described in Section III-B, we
 will analyze the privacy and security of the proposed protocol
 in this section.
 1) Forward Security
 In the proposed protocol, to trace the previous behavior of
 the target tag, an adversary can perform the following steps:
 Phase 1 (Learning): The adversary A sends a Cor-
 rupt (T0;K 0) query in the round (i+1) and thus obtains
 (EPCT0s;i; C
 T0
 i ;K
 T0
 i ).
 Phase 2 (Challenge): The adversary A chooses two fresh
 tags T0 and T1 to be tested and sends a Test (i; T0; T1)
 query. Depending on a randomly chosen bit b 2 f0; 1g, A
 is given a tag Tb 2 fT0; T1g. A makes an Execute (R; Tb; i)
 query in the round (i) and as a result, A is given messages
 1873
fNTb1;i 1; C
 Tb
 i 1;M
 Tb
 1;i 1; CN
 Tb
 2;i 1;M
 Tb
 2;i 1g.
 Phase 3 (Guess): Finally, A terminates the game g and
 outputs a bit b0 2 f0; 1g as the guess value of b. A computes
 EPCT0s  N
 Tb
 1;i 1  M
 Tb
 1;i 1 =  where  is a 16-bit string.
 Theorem 1: During the above game g, if A cannot derive
 the value of  from the tag’s responding messages, i.e., A
 cannot judge what he received is T0 or T1, that is, A is
 unable to determine the value of b0. Thus, the A’s advantage
 AdvUPrivA (k) is negligible.
 Proof: By the fact that EPCs is a permanent value in
 the all rounds of the protocol, we have EPCT0s;i=EPC
 T0
 s;i 1. By
 performing the first two steps (Learning and Challenge), the
 adversary A obtains the above messages including the tag’s
 responding message in the round (i):
 MTb1;i 1 = EPCs  N
 Tb
 1;i 1  K
 Tb
 i 1
 CNTb2;i 1 = N
 Tb
 2;i 1  PRNG(K
 Tb
 i 1)
 MTb2;i 1 = CRC(EPCs  N
 Tb
 2;i 1  C
 Tb
 i 1) K
 Tb
 i 1
 The adversary A computes EPCT0s  N
 Tb
 1;i 1 M
 Tb
 1;i 1 =  .
 From the structure of the tag’s responding message above we
 can see: it is infeasible to derive the secret key KTbi 1 without
 the temporary privacy key NTb2;i 1, although we know M
 Tb
 1;i 1,
 CNTb2;i 1 and M
 Tb
 2;i 1. Therefore, the adversary A couldn’t
 distinguish T0 from T1, i.e., A can not determine the value
 of b0. So, the advantage AdvUPrivA (k) is negligible, i.e., our
 protocol guarantees the forward security.
 2) Privacy of tags
 In our protocol, to trace the target tag, an adversary can
 perform the following steps:
 Phase 1 (Learning): The adversary A sends an Execute
 (R; T0; i + 1) query in the round (i + 1) and thus obtain
 (CT0i ;M
 T0
 1;i ; CN
 T0
 2;i ;M
 T0
 2;i ).
 Phase 2 (Challenge): The adversary A chooses two fresh
 tags T0 and T1 to be tested and sends a Test (i + 1; T0; T1)
 query. Depending on a randomly chosen bit b 2 f0; 1g, A is
 given a tag Tb 2 fT0; T1g. A makes an Execute (R; Tb; i+ 1)
 query in the round (i+1) and as a result, A is given messages
 (CTbi ;M
 Tb
 1;i; CN
 Tb
 2;i;M
 Tb
 2;i).
 Phase 3 (Guess): Finally, A terminates the game g and
 outputs a bit b0 2 f0; 1g as its guess of the value of b.
 Theorem 2: During the above game g, if A cannot make
 sure whether the obtained messages come from the same tag,
 i.e., A cannot distinguish T0 from T1, that is, A is unable to
 determine the value of b0. Then, A’s advantage AdvUPrivA (k)
 is negligible.
 Proof: The responding messages obtained by the adver-
 sary A in Phase 1 are as follows:
 MT01;i = EPC
 T0
 s  N1  K
 T0
 i
 CNT02;i = N
 T0
 2;i  PRNG(K
 T0
 i )
 MT02;i = CRC(EPC
 T0
 s  N
 T0
 2;i  C
 T0
 i ) K
 T0
 i
 And the received messages in Phase 2 are as follows:
 MTb1;i = EPC
 Tb
 s  N1  K
 Tb
 i
 CNTb2;i = N
 Tb
 2;i  PRNG(K
 Tb
 i )
 MTb2;i = CRC(EPC
 Tb
 s  N
 Tb
 2;i  C
 Tb
 i ) K
 Tb
 i
 From the structures of these messages, we can see: The
 query message N1, which will be used in the expression of
 M1, is chosen randomly, and in addition, the message M1 is
 relative to the secret key Ki, where Ki = Ki 1 (N2  l=2).
 So, the message M1 varies dynamically each session because
 of N1 although the shared secret key Ki is not updated. In
 addition, the random number N2, which then is used in the
 expressions of CN2 and M2, is chosen randomly by the tag.
 So, it is absolutely possible to guarantee that the value of CN2
 is different in each session, as well as M2. Therefore, the
 adversary A couldn’t distinguish T0 from T1, i.e., A doesn’t
 determine the value of b0, and the advantage AdvUPrivA (k) is
 negligible. So, our protocol achieves the untraceability.
 B. Performance Analysis
 From the structure of the protocol messages, we can see
 that the complexity of deriving EPCs and Ki from the message
 (N1;M1) is 232, where M1 =EPCs N1 Ki. The complexity
 of deriving EPCs and Ki from the message M2 is 248 where
 M2 =CRC(EPCs  N2  Ci)  Ki and N2 is secure. In
 addition, since the M1 and M2 are independent of each other,
 the adversary needs at least 232 executions of the exhaustive
 search operations to derive EPCs and Ki. Compared with the
 complexity of the SRP protocol 216, our protocol is effective
 to resist the exhaustive search attack.
 TABLE II. STORAGE REQUIREMENTS
 Storage SRP Our protocol
 Server 7l 5l
 Tag 4l 3l
 l: The bit-length of a tag identifier
 TABLE III. COMPUTATION REQUIREMENTS
 computation SRP Our protocol
 Serve
 On receiving the 2nd flow 2F 2F
 On sending the 3rd flow 1F 1F
 On updating or refreshing 3F 1F
 Total 6F 4F
 Tag
 On sending the 2nd flow 2F 2F
 On receiving the 3rd flow 1F 1F
 On updating or refreshing 3F 1F
 Total 6F 4F
 F : A computationally complex function (such as PRNG, CRC)
 Here, we make comparisons between our protocol and
 the SRP protocol in terms of the storage and computation
 requirements respectively as shown in Table II and Table III,
 which show that our protocol reduces the storage overhead and
 the computation overhead.
 V. CONCLUSION
 To heal the weaknesses existing in the SRP protocol, a
 novel RFID authentication protocol conforming to the EPC C-
 1 G-2 standard is proposed, which guarantees the tag’s privacy
 and satisfies the security requirements. This scheme further
 reduces the storage and the computation cost compared with
 1874
the SRP protocol. It is worth mentioning that the proposed
 scheme has the absolute advantage in the security, although
 we improve a little in terms of performance.
 ACKNOWLEDGMENT
 This work is supported by the National Natural Science
 Foundation of China under Grant Nos. 61103178, 61103199
 and 60803151; the Research Fund for the Doctoral Program of
 Higher Education of China under Grant No.20096102120045.
 REFERENCES
 [1] S. A. Weis, S. E. Sarma, R. L. Rivest, and D. W. Engels, “Security And
 Privacy Aspects of Low-Cost Radio Frequency Identification Systems,”
 In proceedings of the 1th International Conference Security in pervasive
 computing, 2004,pp.201-212.
 [2] J. Yang, J. Park, H. Lee, K. Ren, and K. Kim, “Mutual authentication
 protocol for low-cost RFID,” Hand out of the Encrypt Workshop On
 RFID and Lightweight Crypto, 2005.
 [3] E. Y. Choi, D. H. Lee, and J. I. Lim, “Anti-cloning protocol suitable to
 EPCglobal Class-1 Generation-2 RFID systems,” Computer Standards &
 Interfaces ,2009,31(6),pp.1124-1130.
 [4] M. H. Habibi, M. Gardeshi, and M. R.Alaghband, “Practical Attacks on
 a RFID Authentication Protocol Conforming to EPC C-1 G-2 Standard,”
 International Journal of UbiComp(IJU),2011, pp.1-13.
 [5] D. Duc, J. Park, H. Lee, et al, “Enhancing security of EPCglobal gen-2
 RFID tag against traceability and cloning,” The 2006 Symposiumon on
 Cryptography and Information Security(SCIS2006), 2006,pp.17-20.
 [6] M. Burmester, B. Medeiros, J. Munilla, and A. Peinado, “Secure EPC
 Gen2 Compliant Radio Frequency Identification,” Proceedings of the 8th
 International Conference on Ad-Hoc, Mobile and Wireless Networks.
 2009.pp.227-240.
 [7] A. Juels, “Strengthening EPC tag against cloning,” In the proceedings of
 the 4th ACM workshop on wireless security (WiSe’05),2005,pp.67-76.
 [8] H. Chien, and C. Chen, “Mutual authentication protocol for RFID
 conforming to EPC class1 generation 2 standards,” Computer Standards
 & Interfaces, 2007, 29(2),pp.254-259.
 [9] P. Pedro, C. H. Julio, M. E. Juan, and R. Arturo, “Cryptanalysis of a novel
 authentication protocol conforming to EPC-C-1G-2 standard,” Computer
 Standards & Interfaces, 2009,31(2),pp.372-380.
 [10] D. Han, and D. Kwon, “Vulnerability of an RFID authentication
 protocol conforming to EPC Class-1 Generation-2 Standards,” Computer
 Standards & Interfaces,2009,31(4) ,pp.648-652.
 [11] T.C. Yeh, Y. J. Wang, T. C. Kuo, and S. S. Wang, “Securing RFID
 systems conforming to EPC Class-1 Generation-2 standard,” Expert
 Systems with Applications, 2010,37(12),pp.7678-7683.
 [12] B. Song, and J. Chris, “RFID Authentication Protocol for Low-cost
 Tags,” The ACM Conference on wireless Network Security (WISEC’08),
 2008,pp.140-147.
 [13] B. Song, and C. J. Mitchell, “Scalable RFID security protocol-
 s supporting tag ownership transfer,” Computer Communications,
 2011,34(4),pp.556-566.
 [14] R.C. Phan, J. Wu, K. Ouafi, and D.R. Stinson, “Privacy Analysis of
 Forward and Backward Untraceable RFID Authentication Schemes,”
 Wireless Personal Communications, 2010,53(2),pp.1-13.
 [15] K. Ouafi, and R.C. Phan, “Traceable Privacy of Recent Provably-Secure
 RFID Protocols,” Applied Cryptography and Network Security, Lecture
 Notes in Computer Science, SpringerCVerlag, 2008,pp.479-489.
 [16] E. J. Yoon, “Improvement of the securing RFID systems conforming to
 EPC Class 1 Generation 2 standard,” Expert Systems with Applications,
 2012, 39(1), pp.1589-1594.
 [17] M.H. Habibi, M. R. Alaghband, M. R. Aref, “Attacks on a Lightweight
 Mutual Authentication Protocol under EPC C-1 G-2 Standard,” Informa-
 tion Security Theory and Practice, Lecture Notes in Computer Science
 6633,Springer-Verlag, 2011,pp.254-263.
 [18] M. H. Habibi, and M. R. Aref, “Security and Privacy Analysis of
 SongCMitchell RFID Authentication Protocol,” Wireless Personal Com-
 munications, Published on line: 10 May 2012.
 [19] M. H. Habibi, M. R. Aref, and D. Ma, “Addressing Flaws in RFID
 Authentication Protocols,” Process in Cryptology- INDOCRYPT 2011
 Lecture Notes in Computer Science 7107, Springer-Verlag, 2011, pp.216-
 235.
 1875
